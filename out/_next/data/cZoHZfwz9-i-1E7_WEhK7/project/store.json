{"pageProps":{"currentProject":{"slug":"store","frontMatter":{"date":"10-10-2015","title":"Excel Store","lang":"Build with Python","description":"Backend with user creation and authentication, excel reading data and transfer in in JSON as response","image":"/images/project/05.jpg","color":"#BE0000","category":"Backend","projectInfo":[{"title":"Client","data":"World wide"},{"title":"Release date","data":"07-06-2024"},{"title":"Tehnology","data":"- Python\n- Rest API\n- Panda\n"},{"title":"Functions","data":"- Excel to JSON \n- User account\n- Custome API\n- Chart creation \n"}],"live":[{"link":"https://excelstore.gabrielchiorcea.tech/"}]},"content":"\r\n## Arhitecture.\r\n\r\nThis application serves as a backend capable of processing and reading data from Excel files. To utilize this backend and connect it to a frontend, a user account is required. The account is essential as it provides a unique API key for authentication and authorization.\r\n\r\nExcel files are read using Pandas, which converts the file content into a DataFrame. Once transformed into a DataFrame, the data is further converted into JSON format based on the specific functions or filters requested. This enables dynamic and customizable data extraction from the Excel file.\r\n\r\nThe Excel file itself is stored in the database as a binary large object (BLOB), ensuring secure and efficient storage\r\n\r\n\r\n<div class=\"image columns-1 sm:columns-2 gap-8\">\r\n\r\n![Python 01.](/images/project/05-01.jpg)\r\n![Python 02.](/images/project/05-02.jpg)\r\n</div>\r\n\r\n\r\n## Get and store the excel file\r\n\r\nThe Excel file is uploaded via the /excel endpoint of the API. At this endpoint, the file undergoes validation to ensure it is an Excel file, even if the frontend does not perform this check. Once validated, the file is renamed for consistency and security.\r\n\r\nThe renaming process involves appending a unique ID, derived from the userâ€™s API key, to the file name. The resulting format is {ID}.xlsx. The renamed file is then securely stored in the database as a BLOB with its new identifier, ensuring traceability and efficient management.\r\n\r\n\r\n```python\r\n@app.route('/excel', methods=['POST'])\r\n@csrf.exempt\r\ndef upload_excel():\r\n    try:\r\n        # Check if a file is present in the request\r\n        if 'file' not in request.files:\r\n            return jsonify({'res': 'No file found in the request'}), 400\r\n        \r\n        file_in = request.files['file']\r\n        id = request.args.get('id')\r\n\r\n        # Validate the user ID parameter\r\n        if not id:\r\n            return jsonify({'res': 'Missing user ID'}), 400\r\n\r\n        # Check if the file name is empty\r\n        if file_in.filename == '':\r\n            return jsonify({'res': 'File name is empty'}), 400\r\n\r\n        # Validate the file extension (only .xlsx and .xls are allowed)\r\n        if not (file_in.filename.endswith('.xlsx') or file_in.filename.endswith('.xls')):\r\n            return jsonify({'res': 'Invalid file type, only Excel files are allowed (.xlsx, .xls)'}), 400\r\n\r\n        file_content = file_in.read()\r\n        \r\n        # Ensure the file is not empty\r\n        if not file_content:\r\n            return jsonify({'res': 'Uploaded file is empty'}), 400\r\n\r\n        # Generate a unique name for the file based on the user ID\r\n        file_name = f\"{id}.xlsx\"\r\n\r\n        # Create a new database record for the Excel file\r\n        new_excel_file = Excel(name=file_name, excel=file_content)\r\n\r\n        # Add the file to the database session and commit\r\n        db.session.add(new_excel_file)\r\n        db.session.commit()\r\n\r\n        return jsonify({'res': 'File uploaded successfully'}), 200\r\n\r\n    except Exception as e:\r\n        # Roll back the database transaction in case of an error\r\n        db.session.rollback()\r\n        print(f\"Error: {e}\")  # Log the error details to the console\r\n        return jsonify({'res': f'An error occurred while processing the file: {str(e)}'}), 500\r\n\r\n```\r\n\r\n## How the backend know what data to give you\r\n\r\nThe below API endpoint, accessible via /<string:para>/<string:ident> with a GET request, dynamically processes Excel files stored in a database. It retrieves the file based on an id query parameter, reads it into a Pandas DataFrame, and executes specific functions depending on the para value (e.g., counting null values, extracting data, summarizing content, filling missing values, or generating charts). The user's existence and identification (ident) are validated against the database, and if necessary, new identification records are created. By utilizing specialized classes (RespondGet and ResponseFill), the endpoint ensures modular and efficient data manipulation while maintaining robust error handling and database consistency.\r\n\r\n\r\n```python\r\n@app.route('/<string:para>/<string:ident>', methods=['GET'])\r\n@csrf.exempt\r\ndef get_with_ident(para, ident):\r\n    identificare = quote(ident)\r\n    id = request.args.get('id')\r\n    filename = str(id)+'.xlsx'\r\n    retrieved_excel_file = Excel.query.filter_by(name=filename).first()\r\n    excel_data = retrieved_excel_file.excel\r\n    excel_df = pd.read_excel(io.BytesIO(excel_data))\r\n    isntance_of_class = RespondGet(excel_df, id)\r\n    isntance_of_fill = ResponseFill(excel_df, id)\r\n    exist = User.query.filter_by(identification=identificare).first()\r\n    identt = Identification.query.filter_by(identification=identificare).first()\r\n\r\n    if(exist != None  and identt != None):\r\n            if para == \"CountNullValue\":\r\n                count = isntance_of_class.resp_get_null()\r\n                return count\r\n            elif para == \"ExtractValue\":\r\n                ex_val = isntance_of_class.resp_get_ex_val()\r\n                return ex_val\r\n            elif para == \"ExcelSummary\":\r\n                sumar = isntance_of_class.resp_get_ex_sumar()\r\n                return sumar\r\n            elif para == 'fillNANW0':\r\n                fill_na = isntance_of_fill.fill_na()\r\n                return fill_na\r\n            elif para == 'Chart':\r\n                chart = isntance_of_class.chart_columns()\r\n                return chart\r\n    elif(exist and identt == None):\r\n\r\n        time = datetime.now()\r\n        ident = Identification(timestamp=time, identification= identificare)\r\n        db.session.add(ident)\r\n        db.session.commit()\r\n        if para == \"CountNullValue\":\r\n            count = isntance_of_class.resp_get_null()\r\n            return count\r\n        elif para == \"ExtractValue\":\r\n            ex_val = isntance_of_class.resp_get_ex_val()\r\n            return ex_val\r\n        elif para == \"ExcelSummary\":\r\n            sumar = isntance_of_class.resp_get_ex_sumar()\r\n            return sumar\r\n        elif para == 'fillNANW0':\r\n            fill_na = isntance_of_fill.fill_na()\r\n            return fill_na\r\n        elif para == 'Chart':\r\n            chart = isntance_of_class.chart_columns()\r\n            return chart\r\n    else:\r\n        return jsonify({'val': exist}), 400\r\n```\r\n\r\n\r\n\r\n"},"nextProject":{"slug":"backend","frontMatter":{"date":"10-10-2013","title":"Backend","lang":"Build with Python","description":"Flask-based backend application providing user authentication and profile management functionalities.","image":"/images/project/04.jpg","color":"#307B93","category":"Backend","projectInfo":[{"title":"Client","data":"World wide"},{"title":"Timeline","data":"In progress, but ready for tests"},{"title":"Tehnology","data":"- Python\n- PyJWT\n- Sqlalchemy/MySQL\n- Werkzeug\n"},{"title":"Functions","data":"- User Authentication\n- Profile Management\n- Account Management \n"}],"live":[{"link":"https://backend.gabrielchiorcea.tech/"}]},"content":"\r\n## Description\r\n\r\nThis backend is a Flask-based web application that provides user authentication and profile management functionalities. It is designed to handle user sign-up, login, profile updates, and account management. The backend interacts with a MySQL database using SQLAlchemy for ORM (Object-Relational Mapping).\r\nThis backend leverages a combination of Flask, SQLAlchemy, PyJWT, MySQL, and Werkzeug to provide a robust and secure user authentication and profile management system. Flask serves as the web framework, SQLAlchemy handles database interactions, PyJWT manages token-based authentication, MySQL stores user data, and Werkzeug provides essential utilities for web application development. This technology stack ensures efficient and secure handling of user data and authentication processes.\r\n\r\n\r\n## PyJWT Usage in This Backend\r\n\r\n#### How PyJWT is Used in This Backend:\r\n\r\n1. Token Generation:\r\nWhen a user logs in, a JWT is generated using the create_access_token function. This token includes the user's ID and an expiration time. The token is then sent in the database, to the client we give a code related to the token, which stores it and includes it in the Authorization header of subsequent requests.\r\n\r\n| id \t| session_string \t| jwt                                                   \t|\r\n|----\t|----------------\t|-------------------------------------------------------\t|\r\n| 44 \t| 8PBV22S        \t| eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmcmVzaCI6Z... \t|\r\n\r\nAs can be seen, nothing relate to the id of the user, the id is inside of jwt and need special decode for extract the ID.\r\n\r\n2. Token Verification:\r\nFor protected routes, the backend verifies the JWT included in the Authorization header of incoming requests. The token is decoded using the jwt.decode function, which extracts the user's ID and other claims. If the token is valid, the request is processed; otherwise, an error response is returned.\r\n\r\n3. Session Management:\r\nThe backend uses JWTs to manage user sessions. When a user logs in, a session is created with the generated token. This session is used to authenticate the user for subsequent requests.\r\n\r\n## Key Features: \r\n### User Authentication:\r\n\r\nSign-Up: Allows users to create an account by providing an email and password. This is keeped it simple.\r\n\r\n```python\r\n@main.route('/creare-cont' , methods=['POST'])\r\ndef insert_data():\r\n    data = request.get_json()\r\n    email = data.get('email')\r\n    password = data.get('password')\r\n    firstName = data.get('firstName')\r\n    lastName = data.get('lastName')\r\n    userName = data.get('username')\r\n\r\n    try: \r\n        has = HashPass.passwordHash(password) \r\n        new_user = User( userName, email, lastName, firstName , has)\r\n        db.session.add(new_user)\r\n        db.session.commit()\r\n        return jsonify({'message': \"The user account is create with succes\"}), 201\r\n    except SQLAlchemyError as e:\r\n        db.session.rollback()\r\n        return jsonify({'error': str(e)}), 500\r\n```\r\n### User Authentication:\r\n\r\nAbout HashPass.passwordHash(password) is a special medotdh I create to hash the password, validate email format and checking for missing fields are done in the FrontEnd, checking for existing email and username \r\nI have a separated function that is used in FrontEnd when input is out of focus, the function is call via API. \r\n\r\nLogin: Users can log in using their email and password. A JWT (JSON Web Token) is generated for authenticated sessions. Dummy profile and social link data are created for new users.\r\n\r\n```python\r\n        if user:\r\n            access_token = create_access_token(identity=check_user.id, expires_delta=datetime.timedelta(days=1))    \r\n            insert_session = Session(add_session_string, access_token)\r\n            dummy_profile = ProfileCard(\r\n                occupation=\"May I ask you what do you do?\",\r\n                homeaddress=\"How far are you ?\",\r\n                country=\"I guess you are from Nice ?\",\r\n                county=\"France ?\",\r\n                user_id=check_user.id,\r\n                image=b\"\"  \r\n            )\r\n            dummy_social_links = SocialLinks(\r\n                linkedin=\"https://linkedin.com/\",\r\n                facebook=\"https://facebook.com/\",\r\n                github=\"https://github.com/\",\r\n                instagram=\"https://instagram.com/\",\r\n                twitter=\"https://twitter.com/\",\r\n                youtube=\"https://youtube.com/\",\r\n                description=\"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\",\r\n                user_id=check_user.id\r\n            )            \r\n\r\n            db.session.add(insert_session)\r\n            db.session.commit()\r\n\r\n            db.session.add(dummy_profile)\r\n            db.session.commit()\r\n\r\n            db.session.add(dummy_social_links)\r\n            db.session.commit()\r\n            return jsonify({'message': add_session_string}), 200\r\n        else:   \r\n            return jsonify({'message': 'Password or user are incorrect'}), 202\r\n```\r\n\r\n### Profile Management:\r\n\r\nSet Contact Details: Allows users to update their contact details, including occupation, home address, country, county, and profile image.\r\n\r\n\r\nSet Social Links: Allows users to update their social links, such as LinkedIn, Facebook, GitHub, Instagram, Twitter, and YouTube.\r\n\r\n```python\r\n# Retrieve the existing social links\r\n            social_links = SocialLinks.query.filter_by(user_id=user_id).first()\r\n\r\n            if social_links:\r\n                # Update the existing social links with new data\r\n                social_links.linkedin = data.get(\"linkedIn\", social_links.linkedin)\r\n                social_links.facebook = data.get(\"faceBook\", social_links.facebook)                \r\n                social_links.github = data.get(\"gitHub\", social_links.github)            \r\n                social_links.instagram = data.get(\"instagram\", social_links.instagram)            \r\n                social_links.twitter = data.get(\"twitter\", social_links.twitter)                \r\n                social_links.youtube = data.get(\"youtube\", social_links.youtube)\r\n                social_links.description = data.get(\"description\", social_links.description)\r\n```\r\nI use this approach because this is an update.\r\n\r\n\r\nGet Profile: Retrieves the user's profile information, including occupation, home address, country, county, and social links.\r\n\r\n```python\r\n    try:\r\n        decoded_token = jwt.decode(ses.jwt, secret_key, algorithms=[\"xxxxx\"])\r\n        user_id = decoded_token.get('sub')  # Extract user ID from 'sub' key\r\n    except jwt.DecodeError as e:\r\n        return jsonify({'error': 'Invalid token format', 'message': str(e)}), 400\r\n    except jwt.ExpiredSignatureError:\r\n        return jsonify({'error': 'Token has expired'}), 401\r\n    except jwt.InvalidTokenError as e:\r\n        return jsonify({'error': 'Invalid token', 'message': str(e)}), 401\r\n\r\n\r\n\r\n        `````````````````````````````````````````````````````````````````````````````````````\r\n\r\n         profile = ProfileCard.query.filter_by(user_id=user_id).first()\r\n    social_links = SocialLinks.query.filter_by(user_id=user_id).first()\r\n    user = User.query.filter_by(id=user_id).first()\r\n    if not profile:\r\n        return jsonify({'error': 'Profile or user not found'}), 404\r\n    image_base64 = base64.b64encode(profile.image).decode('utf-8')\r\n    return jsonify({\r\n        'HomeAddress': profile.homeaddress,\r\n        'Country': profile.country,\r\n        'County': profile.county,\r\n        'Occupation': profile.occupation,\r\n        'Image': image_base64,  # Assuming image is stored as binary data\r\n        'FullName': ' '.join([user.first_name, user.last_name]),\r\n        'Email': user.email,\r\n        'LinkedIn': social_links.linkedin,\r\n        'FaceBook': social_links.facebook,\r\n        'GitHub': social_links.github,\r\n        'Instagram': social_links.instagram,\r\n        'Twitter': social_links.twitter,\r\n        'Youtube': social_links.youtube,\r\n        'Description': social_links.description\r\n\r\n    }), 200\r\n```\r\n\r\n### Account Management:\r\n\r\nEverything start with chinkd the jwt:\r\n\r\n```python\r\nses = Session.query.filter_by(session_string=token).first()\r\ndecoded_token = jwt.decode(ses.jwt, secret_key, algorithms=[\"#####\"])\r\n```\r\n\r\nChange Password: Allows users to change their password by providing the current password and a new password.\r\n```python\r\n # Verify the current password\r\n        if not HashPass.check_password(user.password, current_password):\r\n            return jsonify({'message': 'Current password is incorrect'}), 400\r\n\r\n        # Update the password\r\n        user.password = HashPass.passwordHash(new_password)\r\n        db.session.commit()\r\n```\r\n\r\nChange Email: Allows users to update their email address.\r\n```python\r\n user = User.query.filter_by(id=user_id).first()\r\n        if not user:\r\n            return jsonify({'message': 'User not found'}), 404\r\n\r\n        # Update the email\r\n        user.email = new_email\r\n        db.session.commit()\r\n```\r\nChange Username: Allows users to update their username, ensuring the new username is not already taken.\r\n```python\r\nexisting_user = User.query.filter_by(username=new_username).first()\r\n        if existing_user:\r\n            return jsonify({'message': 'Username already taken'}), 400\r\n\r\n        # Update the username\r\n        user.username = new_username\r\n        db.session.commit()\r\n```\r\n\r\nDelete Account: Allows users to delete their account and all related data, including profile and social links.\r\n```python\r\nser = User.query.filter_by(id=user_id).first()\r\n        if not user:\r\n            return jsonify({'message': 'User not found'}), 404\r\n\r\n        # Delete related records\r\n        ProfileCard.query.filter_by(user_id=user_id).delete()\r\n        SocialLinks.query.filter_by(user_id=user_id).delete()\r\n\r\n        # Delete the user record\r\n        db.session.delete(user)\r\n        db.session.commit()\r\n```\r\n\r\nTechnologies Used:\r\nFlask: A lightweight WSGI web application framework in Python.\r\nSQLAlchemy: An ORM library for managing database interactions.\r\nPyJWT: A Python library for working with JSON Web Tokens.\r\nMySQL: A relational database management system for storing user data.\r\nWerkzeug: A comprehensive WSGI web application library used for password hashing and security.\r\n\r\nExample Endpoints:\r\n1.  POST /intra-in-cont: Sign up a new user.\r\n2.  POST /login: Log in an existing user.\r\n3.  GET /getProfile: Retrieve the user's profile information.\r\n4.  POST /setContactDetail: Update the user's contact details.\r\n6.  POST /setSocialLink: Update the user's social links.\r\n7.  POST /changePassword: Change the user's password.\r\n8.  POST /changeEmail: Change the user's email address.\r\n9.  POST /changeUsername: Change the user's username.\r\n10. DELETE /deleteAccount: Delete the user's account and all related data.\r\n\r\nThis backend provides a robust foundation for user authentication and profile management, ensuring secure and efficient handling of user data.\r\n\r\nThis description provides a comprehensive overview of the backend's functionality, key features, and technologies used. Adjust the details as needed to match your specific implementation.\r\n\r\n\r\n"}},"__N_SSG":true}