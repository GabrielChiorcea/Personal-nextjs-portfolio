{"pageProps":{"currentProject":{"slug":"backend","frontMatter":{"date":"10-10-2013","title":"Backend","lang":"Build with Python","description":"Flask-based backend application providing user authentication and profile management functionalities.","image":"/images/project/04.jpg","color":"#307B93","category":"Backend","projectInfo":[{"title":"Client","data":"World wide"},{"title":"Timeline","data":"In progress, but ready for tests"},{"title":"Tehnology","data":"- Python\n- PyJWT\n- Sqlalchemy/MySQL\n- Werkzeug\n"},{"title":"Functions","data":"- User Authentication\n- Profile Management\n- Account Management \n"}],"live":[{"link":"https://backend.gabrielchiorcea.tech/"}]},"content":"\r\n## Description\r\n\r\nThis backend is a Flask-based web application that provides user authentication and profile management functionalities. It is designed to handle user sign-up, login, profile updates, and account management. The backend interacts with a MySQL database using SQLAlchemy for ORM (Object-Relational Mapping).\r\nThis backend leverages a combination of Flask, SQLAlchemy, PyJWT, MySQL, and Werkzeug to provide a robust and secure user authentication and profile management system. Flask serves as the web framework, SQLAlchemy handles database interactions, PyJWT manages token-based authentication, MySQL stores user data, and Werkzeug provides essential utilities for web application development. This technology stack ensures efficient and secure handling of user data and authentication processes.\r\n\r\n\r\n## PyJWT Usage in This Backend\r\n\r\n#### How PyJWT is Used in This Backend:\r\n\r\n1. Token Generation:\r\nWhen a user logs in, a JWT is generated using the create_access_token function. This token includes the user's ID and an expiration time. The token is then sent in the database, to the client we give a code related to the token, which stores it and includes it in the Authorization header of subsequent requests.\r\n\r\n| id \t| session_string \t| jwt                                                   \t|\r\n|----\t|----------------\t|-------------------------------------------------------\t|\r\n| 44 \t| 8PBV22S        \t| eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmcmVzaCI6Z... \t|\r\n\r\nAs can be seen, nothing relate to the id of the user, the id is inside of jwt and need special decode for extract the ID.\r\n\r\n2. Token Verification:\r\nFor protected routes, the backend verifies the JWT included in the Authorization header of incoming requests. The token is decoded using the jwt.decode function, which extracts the user's ID and other claims. If the token is valid, the request is processed; otherwise, an error response is returned.\r\n\r\n3. Session Management:\r\nThe backend uses JWTs to manage user sessions. When a user logs in, a session is created with the generated token. This session is used to authenticate the user for subsequent requests.\r\n\r\n## Key Features: \r\n### User Authentication:\r\n\r\nSign-Up: Allows users to create an account by providing an email and password. This is keeped it simple.\r\n\r\n```python\r\n@main.route('/creare-cont' , methods=['POST'])\r\ndef insert_data():\r\n    data = request.get_json()\r\n    email = data.get('email')\r\n    password = data.get('password')\r\n    firstName = data.get('firstName')\r\n    lastName = data.get('lastName')\r\n    userName = data.get('username')\r\n\r\n    try: \r\n        has = HashPass.passwordHash(password) \r\n        new_user = User( userName, email, lastName, firstName , has)\r\n        db.session.add(new_user)\r\n        db.session.commit()\r\n        return jsonify({'message': \"The user account is create with succes\"}), 201\r\n    except SQLAlchemyError as e:\r\n        db.session.rollback()\r\n        return jsonify({'error': str(e)}), 500\r\n```\r\n### User Authentication:\r\n\r\nAbout HashPass.passwordHash(password) is a special medotdh I create to hash the password, validate email format and checking for missing fields are done in the FrontEnd, checking for existing email and username \r\nI have a separated function that is used in FrontEnd when input is out of focus, the function is call via API. \r\n\r\nLogin: Users can log in using their email and password. A JWT (JSON Web Token) is generated for authenticated sessions. Dummy profile and social link data are created for new users.\r\n\r\n```python\r\n        if user:\r\n            access_token = create_access_token(identity=check_user.id, expires_delta=datetime.timedelta(days=1))    \r\n            insert_session = Session(add_session_string, access_token)\r\n            dummy_profile = ProfileCard(\r\n                occupation=\"May I ask you what do you do?\",\r\n                homeaddress=\"How far are you ?\",\r\n                country=\"I guess you are from Nice ?\",\r\n                county=\"France ?\",\r\n                user_id=check_user.id,\r\n                image=b\"\"  \r\n            )\r\n            dummy_social_links = SocialLinks(\r\n                linkedin=\"https://linkedin.com/\",\r\n                facebook=\"https://facebook.com/\",\r\n                github=\"https://github.com/\",\r\n                instagram=\"https://instagram.com/\",\r\n                twitter=\"https://twitter.com/\",\r\n                youtube=\"https://youtube.com/\",\r\n                description=\"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\",\r\n                user_id=check_user.id\r\n            )            \r\n\r\n            db.session.add(insert_session)\r\n            db.session.commit()\r\n\r\n            db.session.add(dummy_profile)\r\n            db.session.commit()\r\n\r\n            db.session.add(dummy_social_links)\r\n            db.session.commit()\r\n            return jsonify({'message': add_session_string}), 200\r\n        else:   \r\n            return jsonify({'message': 'Password or user are incorrect'}), 202\r\n```\r\n\r\n### Profile Management:\r\n\r\nSet Contact Details: Allows users to update their contact details, including occupation, home address, country, county, and profile image.\r\n\r\n\r\nSet Social Links: Allows users to update their social links, such as LinkedIn, Facebook, GitHub, Instagram, Twitter, and YouTube.\r\n\r\n```python\r\n# Retrieve the existing social links\r\n            social_links = SocialLinks.query.filter_by(user_id=user_id).first()\r\n\r\n            if social_links:\r\n                # Update the existing social links with new data\r\n                social_links.linkedin = data.get(\"linkedIn\", social_links.linkedin)\r\n                social_links.facebook = data.get(\"faceBook\", social_links.facebook)                \r\n                social_links.github = data.get(\"gitHub\", social_links.github)            \r\n                social_links.instagram = data.get(\"instagram\", social_links.instagram)            \r\n                social_links.twitter = data.get(\"twitter\", social_links.twitter)                \r\n                social_links.youtube = data.get(\"youtube\", social_links.youtube)\r\n                social_links.description = data.get(\"description\", social_links.description)\r\n```\r\nI use this approach because this is an update.\r\n\r\n\r\nGet Profile: Retrieves the user's profile information, including occupation, home address, country, county, and social links.\r\n\r\n```python\r\n    try:\r\n        decoded_token = jwt.decode(ses.jwt, secret_key, algorithms=[\"xxxxx\"])\r\n        user_id = decoded_token.get('sub')  # Extract user ID from 'sub' key\r\n    except jwt.DecodeError as e:\r\n        return jsonify({'error': 'Invalid token format', 'message': str(e)}), 400\r\n    except jwt.ExpiredSignatureError:\r\n        return jsonify({'error': 'Token has expired'}), 401\r\n    except jwt.InvalidTokenError as e:\r\n        return jsonify({'error': 'Invalid token', 'message': str(e)}), 401\r\n\r\n\r\n\r\n        `````````````````````````````````````````````````````````````````````````````````````\r\n\r\n         profile = ProfileCard.query.filter_by(user_id=user_id).first()\r\n    social_links = SocialLinks.query.filter_by(user_id=user_id).first()\r\n    user = User.query.filter_by(id=user_id).first()\r\n    if not profile:\r\n        return jsonify({'error': 'Profile or user not found'}), 404\r\n    image_base64 = base64.b64encode(profile.image).decode('utf-8')\r\n    return jsonify({\r\n        'HomeAddress': profile.homeaddress,\r\n        'Country': profile.country,\r\n        'County': profile.county,\r\n        'Occupation': profile.occupation,\r\n        'Image': image_base64,  # Assuming image is stored as binary data\r\n        'FullName': ' '.join([user.first_name, user.last_name]),\r\n        'Email': user.email,\r\n        'LinkedIn': social_links.linkedin,\r\n        'FaceBook': social_links.facebook,\r\n        'GitHub': social_links.github,\r\n        'Instagram': social_links.instagram,\r\n        'Twitter': social_links.twitter,\r\n        'Youtube': social_links.youtube,\r\n        'Description': social_links.description\r\n\r\n    }), 200\r\n```\r\n\r\n### Account Management:\r\n\r\nEverything start with chinkd the jwt:\r\n\r\n```python\r\nses = Session.query.filter_by(session_string=token).first()\r\ndecoded_token = jwt.decode(ses.jwt, secret_key, algorithms=[\"#####\"])\r\n```\r\n\r\nChange Password: Allows users to change their password by providing the current password and a new password.\r\n```python\r\n # Verify the current password\r\n        if not HashPass.check_password(user.password, current_password):\r\n            return jsonify({'message': 'Current password is incorrect'}), 400\r\n\r\n        # Update the password\r\n        user.password = HashPass.passwordHash(new_password)\r\n        db.session.commit()\r\n```\r\n\r\nChange Email: Allows users to update their email address.\r\n```python\r\n user = User.query.filter_by(id=user_id).first()\r\n        if not user:\r\n            return jsonify({'message': 'User not found'}), 404\r\n\r\n        # Update the email\r\n        user.email = new_email\r\n        db.session.commit()\r\n```\r\nChange Username: Allows users to update their username, ensuring the new username is not already taken.\r\n```python\r\nexisting_user = User.query.filter_by(username=new_username).first()\r\n        if existing_user:\r\n            return jsonify({'message': 'Username already taken'}), 400\r\n\r\n        # Update the username\r\n        user.username = new_username\r\n        db.session.commit()\r\n```\r\n\r\nDelete Account: Allows users to delete their account and all related data, including profile and social links.\r\n```python\r\nser = User.query.filter_by(id=user_id).first()\r\n        if not user:\r\n            return jsonify({'message': 'User not found'}), 404\r\n\r\n        # Delete related records\r\n        ProfileCard.query.filter_by(user_id=user_id).delete()\r\n        SocialLinks.query.filter_by(user_id=user_id).delete()\r\n\r\n        # Delete the user record\r\n        db.session.delete(user)\r\n        db.session.commit()\r\n```\r\n\r\nTechnologies Used:\r\nFlask: A lightweight WSGI web application framework in Python.\r\nSQLAlchemy: An ORM library for managing database interactions.\r\nPyJWT: A Python library for working with JSON Web Tokens.\r\nMySQL: A relational database management system for storing user data.\r\nWerkzeug: A comprehensive WSGI web application library used for password hashing and security.\r\n\r\nExample Endpoints:\r\n1.  POST /intra-in-cont: Sign up a new user.\r\n2.  POST /login: Log in an existing user.\r\n3.  GET /getProfile: Retrieve the user's profile information.\r\n4.  POST /setContactDetail: Update the user's contact details.\r\n6.  POST /setSocialLink: Update the user's social links.\r\n7.  POST /changePassword: Change the user's password.\r\n8.  POST /changeEmail: Change the user's email address.\r\n9.  POST /changeUsername: Change the user's username.\r\n10. DELETE /deleteAccount: Delete the user's account and all related data.\r\n\r\nThis backend provides a robust foundation for user authentication and profile management, ensuring secure and efficient handling of user data.\r\n\r\nThis description provides a comprehensive overview of the backend's functionality, key features, and technologies used. Adjust the details as needed to match your specific implementation.\r\n\r\n\r\n"},"nextProject":{"slug":"checker","frontMatter":{"date":"10-10-2023","title":"Checker","lang":"Build with C#","description":"This project is an interactive web application developed with Blazor WebAssembly, utilizing Fluxor for state management and including custom services for authentication and handling HTTP requests.","image":"/images/project/03.jpg","color":"#BF4106","category":"Frontend","projectInfo":[{"title":"Client","data":"World wide"},{"title":"Timeline","data":"In progress, but ready for tests"},{"title":"Tehnology","data":"- Blazor\n- Fluxor \n- Bootstrap  \n"},{"title":"Functions","data":"- Post Like\n- User Account\n- Activity track\n- Share post \n"}],"live":[{"link":"https://checker.gabrielchiorcea.tech/"}]},"content":"\r\n\r\n<div class=\"image columns-1 sm:columns-2 gap-8\">\r\n\r\n\r\n![C# 02.](/images/project/03-02.jpg)\r\n![C# 01.](/images/project/03-01.jpg)\r\n![C# 03.](/images/project/03-03.jpg)\r\n![C# 03.](/images/project/03-04.jpg)\r\n\r\n\r\n</div>\r\n\r\n\r\n## Project Overview\r\n\r\nChecker is a web application designed to manage user profiles and account settings. It provides functionalities for viewing and updating profile information, changing passwords, and deleting accounts. The application aims to offer a seamless user experience with a responsive design.\r\n\r\n\r\n\r\n## Program.cs Description\r\n\r\nThe Program.cs file is the entry point for a Blazor WebAssembly application. It configures the root components, sets up services, configures Fluxor for state management, and sets the logging configuration. Finally, it builds and runs the application asynchronously. This file ensures that the application is properly initialized and configured before it starts running.\r\n\r\nKey Components:\r\n1. Root Components\r\n2. Service Configuration\r\n3. Fluxor Configuration\r\n4. Logging Configuration\r\n5. Application Initialization\r\n6. Description of Visible Code\r\n7. Root Components\r\n\r\nThe root components of the Blazor application are added to the component tree. These components are the entry points for the application and are rendered in the specified HTML elements.\r\n\r\n```C\r\nbuilder.RootComponents.Add<App>(\"#app\");\r\nbuilder.RootComponents.Add<HeadOutlet>(\"head::after\");\r\n```\r\n* App: The main application component, rendered in the HTML element with the ID app.\r\n\r\n* HeadOutlet: A component for rendering content in the HTML <head> element, rendered after the existing content.\r\n\r\n\r\nService Configuration\r\nServices are configured and added to the dependency injection container. These services can be injected into components and other services throughout the application.\r\n\r\n```C#\r\nbuilder.Services.AddScoped(sp => new HttpClient { BaseAddress = new Uri(builder.HostEnvironment.BaseAddress) });\r\nbuilder.Services.AddScoped<FetchService>();\r\nbuilder.Services.AddScoped<AuthenticationTocken>();\r\n```\r\n\r\n* HttpClient: Configured with the base address of the host environment.\r\n* FetchService: A custom service for handling HTTP requests.\r\n* AuthenticationTocken: A custom service for managing authentication tokens.\r\n\r\n\r\nFluxor Configuration\r\nFluxor, a state management library for Blazor, is configured and added to the services.\r\n```C#\r\nbuilder.Services.AddFluxor(o =>\r\n{\r\n    o.ScanAssemblies(typeof(Program).Assembly);\r\n    o.UseReduxDevTools();\r\n});\r\n```\r\n\r\n* ScanAssemblies: Scans the specified assembly for Fluxor-related classes (e.g., actions, reducers, effects).\r\n* UseReduxDevTools: Enables Redux DevTools integration for state debugging.\r\n\r\n\r\nLogging Configuration\r\nThe logging configuration is set to a minimum level of Information.\r\n```C#\r\nbuilder.Logging.SetMinimumLevel(LogLevel.Information);\r\n```\r\nApplication Initialization\r\nThe application is built and run asynchronously.\r\n\r\n```C#\r\nawait builder.Build().RunAsync();\r\n```\r\n\r\n\r\n## Pages\r\n\r\nThe Signup.razor file is a Blazor component that handles the user sign-up process. This component includes a form where users can enter their email, username, and password to create a new account. The component also manages the state of the form, including validation and error handling.\r\n\r\nKey Components:\r\n1. Form Fields: The form includes input fields for the user's email, username, and password.\r\nState Management: The component manages the state of the form fields, including validation states and error messages.\r\n2. Event Handling: The component includes methods to handle form submission and validation.\r\n\r\n3. UI Feedback: The component provides visual feedback to the user based on the validation state of the form fields.\r\n\r\nDescription of Visible Code\r\n1. Message Handling: The code sets a message to \"false\" and updates the styleClassUsername to indicate a valid username. It also sets the userName flag to true.\r\n2. Exception Handling: The code includes a try-catch block to handle exceptions during the verification process, logging any errors to the console.\r\n3. State Management: The stateManager method updates the state of the form, resetting the style classes for the email and username input fields to their default state.\r\n\r\nThe Signup.razor component is responsible for handling the user sign-up process in a Blazor application. It includes form fields for user input, manages the state of these fields, handles form submission and validation, and provides visual feedback to the user. The visible code snippet shows how the component updates the state and handles exceptions during the verification process.\r\n\r\nProfileRender.razor Description\r\nThe ProfileRender.razor component is responsible for rendering the user's profile information in a Blazor application. This component typically includes the following functionalities:\r\n\r\n1. Profile Data Fetching: The component fetches the user's profile data from a service or state management store when the component is initialized.\r\n2. Profile Display: The component displays the user's profile information, such as name, email, and other relevant details, in a structured format.\r\n3. Profile Update: The component may include functionality to update the user's profile information, allowing users to edit and save changes to their profile.\r\n4. DOM Manipulation: The ProfileDom method is likely used to manipulate or render the profile DOM structure, ensuring that the profile information is displayed correctly and dynamically updated based on user interactions or other events.\r\n\r\nKey Components\r\n1. Profile Data Fetching: The component fetches the user's profile data, using FetchService.\r\n2. Profile Display: The component displays the profile information in a user-friendly format, such as a form or a set of labeled fields.\r\n3. Profile Update: The component may provide input fields and buttons to allow users to update their profile information.\r\n4. DOM Manipulation: The ProfileDom method is used to handle any necessary DOM manipulations to ensure the profile information is displayed and updated correctly.\r\n\r\nThe ProfileRender.razor component is a crucial part of the user interface in a Blazor application, responsible for displaying and managing the user's profile information. It fetches the profile data, displays it in a structured format, and may provide functionality for users to update their profile information. The ProfileDom method is used to handle any necessary DOM manipulations, ensuring that the profile information is displayed and updated correctly based on user interactions or other events.\r\n\r\n\r\n## HTTP\r\n\r\nThe http request are defines by  FetchService class in the Checker.Services namespace. The class is designed to handle HTTP requests and interactions with JavaScript runtime in a Blazor WebAssembly application.\r\n\r\nHere are the key components:\r\n\r\nNamespaces: The code imports several namespaces required for HTTP operations, JSON handling, state management, and JavaScript interop.\r\n\r\n1. System.Net\r\n2. System.Net.Http.Headers\r\n3. System.Net.Http.Json\r\n4. Checker.Models\r\n5. Checker.state\r\n6. Fluxor\r\n7. Microsoft.JSInterop\r\nNamespace Declaration: The FetchService class is declared within the Checker.Services namespace.\r\n\r\nClass Declaration: The FetchService class is declared as a public class.\r\n\r\nPrivate Fields:\r\n\r\n_httpClinet: A private readonly field of type HttpClient for making HTTP requests.\r\n\r\n_jsRuntime: A private readonly field of type IJSRuntime for interacting with JavaScript. \r\n\r\nConstructor: The constructor initializes the _httpClinet and _jsRuntime fields with the provided HttpClient and IJSRuntime instances.\r\n\r\n## Method\r\n\r\n### LoginAsync\r\n\r\nThis method handles user login by sending a POST request with the login model and returns a token.\r\n\r\n```C#\r\npublic async Task<JsonModel> LoginAsync(LoginModel loginModel)\r\n{\r\n    var response = await _httpClinet.PostAsJsonAsync($\"{AppSettings.ApiBaseUrl}/creare-cont\", loginModel);\r\n    response.EnsureSuccessStatusCode();\r\n    var token = await response.Content.ReadFromJsonAsync<JsonModel>();\r\n    return token;\r\n}\r\n```\r\n### SignUpAsync\r\nThis method handles user sign-up by sending a POST request with the sign-up model and returns a response model.\r\n\r\n```C#\r\npublic async Task<SignUpResponseModel> SignUpAsync(SignUpModel signUpModel)\r\n{\r\n    var response = await _httpClinet.PostAsJsonAsync($\"{AppSettings.ApiBaseUrl}/inregistrare\", signUpModel);\r\n    response.EnsureSuccessStatusCode();\r\n    var result = await response.Content.ReadFromJsonAsync<SignUpResponseModel>();\r\n    return result;\r\n}\r\n```\r\n\r\n## Additional Methods like\r\n\r\n### GetUserProfileAsync\r\n\r\nThis method retrieves the user's profile by sending a GET request.\r\n```C#\r\npublic async Task<UserProfileModel> GetUserProfileAsync(string token)\r\n{\r\n    var request = new HttpRequestMessage(HttpMethod.Get, $\"{AppSettings.ApiBaseUrl}/profil\");\r\n    request.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", token);\r\n    var response = await _httpClinet.SendAsync(request);\r\n    response.EnsureSuccessStatusCode();\r\n    return await response.Content.ReadFromJsonAsync<UserProfileModel>();\r\n}\r\n```\r\n\r\n### UpdateUserProfileAsync\r\n\r\nThis method updates the user's profile by sending a PUT request with the updated profile model.\r\n\r\n```C#\r\npublic async Task<HttpResponseMessage> UpdateUserProfileAsync(UserProfileModel profileModel, string token)\r\n{\r\n    var request = new HttpRequestMessage(HttpMethod.Put, $\"{AppSettings.ApiBaseUrl}/profil\");\r\n    request.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", token);\r\n    request.Content = JsonContent.Create(profileModel);\r\n    return await _httpClinet.SendAsync(request);\r\n}\r\n```\r\nThe FetchService class provides a comprehensive set of methods for handling user authentication and profile management. These methods include logging in, signing up, retrieving user profiles, updating profiles, and logging out. Each method is designed to perform specific tasks by making appropriate HTTP requests or interacting with JavaScript, ensuring a clean and reusable service layer within the Blazor WebAssembly application.\r\n\r\n\r\n## State management\r\n\r\nThe state management in this code is implemented using the Fluxor library, which is a state management library for Blazor applications. The code defines reducers that handle specific actions to update the application's state.\r\n\r\n\r\nLet's focus on the ProfileCardState and how is used in the context of state management with Fluxor.\r\n\r\n### ProfileCardState\r\nThe ProfileCardState likely represents the state of a user's profile card in the application. This state could include information such as the user's profile details, loading status, and any errors.\r\n\r\nDescription\r\nProfileCardState Definition:\r\n\r\nThe ProfileCardState class is defined in the State.cs file. It includes properties like HomeAddress, Country, County, Occupation, FullName, Email, Image, and various social media links.\r\n```C#\r\npublic class ProfileCardState\r\n{\r\n    public string HomeAddress { get; set; }\r\n    public string Country { get; set; }\r\n    public string County { get; set; }\r\n    public string Occupation { get; set; }\r\n    public string FullName { get; set; }\r\n    public string Email { get; set; }\r\n    public byte[] Image { get; set; }\r\n    public string LinkedIn { get; set; }\r\n    public string FaceBook { get; set; }\r\n    public string GitHub { get; set; }\r\n    public string Instagram { get; set; }\r\n    public string Twitter { get; set; }\r\n    public string Youtube { get; set; }\r\n    public string Description { get; set; }\r\n\r\n    public ProfileCardState(string homeAddress, string country, string county, string occupation, string fullname, string email, byte[] image, string linkedIn, string faceBook, string gitHub, string instagram, string twitter, string youtube, string description)\r\n    {\r\n        HomeAddress = homeAddress;\r\n        Country = country;\r\n        County = county;\r\n        Occupation = occupation;\r\n        Image = image;\r\n        FullName = fullname;\r\n        Email = email;\r\n        LinkedIn = linkedIn;\r\n        FaceBook = faceBook;\r\n        GitHub = gitHub;\r\n        Instagram = instagram;\r\n        Twitter = twitter;\r\n        Youtube = youtube;\r\n        Description = description;\r\n    }\r\n\r\n    public ProfileCardState() { }\r\n}\r\n```\r\n\r\n\r\nIt has constructors to initialize these properties, including a parameterless constructor for flexibility.\r\n\r\n\r\nFeature Initialization:\r\n\r\nThe ProfileCardFeature class, defined in the Feature.cs file, specifies the initial state of ProfileCardState with default values.\r\n\r\n```C#\r\nusing Fluxor;\r\n\r\nnamespace Checker.state\r\n{\r\n    public class ProfileCardFeature : Feature<ProfileCardState>\r\n    {\r\n        public override string GetName() => \"ProfileCard\";\r\n\r\n        protected override ProfileCardState GetInitialState() =>\r\n            new ProfileCardState(\r\n                string.Empty, string.Empty, string.Empty, string.Empty, string.Empty, string.Empty, new byte[0], \r\n                string.Empty, string.Empty, string.Empty, string.Empty, string.Empty, string.Empty, \r\n                string.Empty\r\n            );\r\n    }\r\n}\r\n```\r\n\r\nReducers:\r\n\r\nThe ProfileCardReducer class, found in the Reducers.cs file, handles state changes. The ReduceProfileCard method updates the state based on the GetProfileCardState action by creating a new ProfileCardState with updated values.\r\n```C#\r\nusing Fluxor;\r\n\r\nnamespace Checker.state\r\n{\r\n    public static class ProfileCardReducer\r\n    {\r\n        [ReducerMethod]\r\n        public static ProfileCardState ReduceProfileCard(ProfileCardState state, GetProfileCardState action)\r\n        {\r\n            return new ProfileCardState(\r\n                action.State.HomeAddress,\r\n                action.State.Country,\r\n                action.State.County,\r\n                action.State.Occupation,\r\n                action.State.FullName,\r\n                action.State.Email,            \r\n                action.State.Image,\r\n                action.State.LinkedIn,\r\n                action.State.FaceBook,\r\n                action.State.GitHub,\r\n                action.State.Instagram,\r\n                action.State.Twitter,\r\n                action.State.Youtube,\r\n                action.State.Description\r\n            );\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\nUsage in Components:\r\n\r\nIn various Razor components like ProfileRender.razor, HomeRender.razor, and AdminRender.razor, the ProfileCardState is injected and used to display profile information.\r\nThese components fetch user data from the server and dispatch actions to update the state. For example, when the profile page is loaded, it checks the authentication token and fetches the user's profile data to update the state.\r\n\r\n```C#\r\n@page \"/profile\"\r\n\r\n@using Checker.Pages.Message\r\n@using global::Checker.state\r\n@using global::Checker.Models \r\n@using global::Checker.Services\r\n@using global::Checker.features\r\n@using Fluxor\r\n@inject AuthenticationTocken authenticationtocken\r\n@inject IState<ProfileCardState> ProfileCardState\r\n\r\n@inject FetchService fetchService\r\n@inject IDispatcher Dispatcher\r\n\r\n@if(error == false){\r\n    @if(isLoading){\r\n        <BlazorChecking/>\r\n    } else if(tokenState){\r\n        <ProfileDom/>\r\n    }else{\r\n        <Restricted/>\r\n    }\r\n}else{\r\n    <BlazorError/>\r\n}\r\n\r\n@code{\r\n    bool isLoading = true;\r\n    bool error = false;\r\n    bool tokenState;\r\n    protected override async Task OnInitializedAsync()\r\n    {\r\n        tokenState = await authenticationtocken.Check();\r\n        \r\n        if(!string.IsNullOrEmpty(ProfileCardState.Value.FullName)){\r\n            isLoading = false;\r\n            return;\r\n        }\r\n\r\n        string tokenString = await authenticationtocken.GetTocken();\r\n        if(tokenState){\r\n            try{\r\n                var response = await fetchService.GetResponsSocialCard($\"{AppSettings.ApiBaseUrl}/get\", tokenString);\r\n                Dispatcher.Dispatch(new GetProfileCardState(response));\r\n                if(response != null){\r\n                    isLoading = false;\r\n                }else{\r\n                    throw new Exception(\"eroare\");\r\n                }\r\n            } catch (Exception) {\r\n                error = true;\r\n                return;\r\n            }\r\n        }else{\r\n            isLoading = false;\r\n        }\r\n    }\r\n}\r\n```\r\nThis setup ensures consistent management and updating of the profile information across the application using Fluxor.\r\n\r\n\r\n\r\n\r\n"}},"__N_SSG":true}