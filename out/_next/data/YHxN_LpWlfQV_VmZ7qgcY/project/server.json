{"pageProps":{"currentProject":{"slug":"server","frontMatter":{"date":"2004-01-10","title":"Hosting Server","description":"A fully configured server to host all of my projects.","image":"/images/project/06.jpg","color":"#BE0000","category":"Server","projectInfo":[{"title":"Client","data":"Worldwide"},{"title":"Timeline","data":"Completed"},{"title":"Hosting Stack","data":"- **Operating System:** Ubuntu 20.04 LTS\n- **Firewall:** UFW (Uncomplicated Firewall)\n- **Database:** MariaDB\n- **Web Server:** Nginx\n- **Application Server:** Gunicorn\n- **Programming Language:** Python\n- **CI/CD Pipeline:** Jenkins\n- **Monitoring & Logging:** Prometheus & Grafana\n- **Backup & Recovery:** BorgBackup & Restic\n- **Infrastructure as Code:** Ansible & Terraform\n"},{"title":"Functions","data":"- High-performance web hosting\n- Automated deployment\n- Secure and scalable infrastructure\n- Continuous monitoring and alerting\n- Automated backups and disaster recovery\n"}],"live":[{"link":"#"}]},"content":"\r\n## Server Configuration\r\n\r\nTo analyze the implemented configurations, a live session can be arranged where I will provide access for a joint review.\r\n\r\nThis project represents a dedicated hosting server for all my applications, configured to provide performance, security, and scalability. The server is optimized to run modern applications with minimal response time and high reliability.\r\n\r\n### **Firewall (UFW)**\r\nUncomplicated Firewall (UFW) is configured to protect the server by restricting access to necessary ports.\r\n- HTTP (80) and HTTPS (443) for web access\r\n- SSH with IP restrictions for security, dedicate IP.\r\n- Custom ports for internal services\r\n- Rate limiting for brute-force attack protection\r\n\r\n###  **Operating System - Ubuntu 20.04 LTS**\r\nUbuntu 20.04 LTS was chosen for its stability, long-term support, and excellent compatibility with most server-side applications.\r\n- Optimized kernel for performance and security\r\n- Swap tuning for efficient memory management\r\n- Automatic security updates and periodic security audits\r\n\r\n###  **MariaDB - Database Management System**\r\nMariaDB is installed to support applications that require data storage, especially those involving user authentication and account management.\r\n- Configured with master-slave replication for redundancy\r\n- Optimized for performance using query caching and indexing\r\n- Automatic daily backup and fast recovery when needed\r\n- Secure access via SSL connections and role-based authentication\r\n\r\n\r\n```ini\r\n[mysqld]\r\nbind-address = 127.0.0.1\r\nmax_connections = 500\r\nthread_cache_size = 128\r\ntable_open_cache = 4000\r\nquery_cache_type = 1\r\nquery_cache_size = 64M\r\nquery_cache_limit = 2M\r\ntmp_table_size = 64M\r\nmax_heap_table_size = 64M\r\ninnodb_buffer_pool_size = 1G\r\ninnodb_log_file_size = 256M\r\ninnodb_flush_log_at_trx_commit = 1\r\ninnodb_flush_method = O_DIRECT\r\ninnodb_file_per_table = 1\r\ninnodb_read_io_threads = 8\r\ninnodb_write_io_threads = 8\r\nlog_error = /var/log/mysql/error.log\r\nslow_query_log = 1\r\nslow_query_log_file = /var/log/mysql/slow.log\r\nlong_query_time = 1\r\nserver-id = 1\r\nlog_bin = /var/log/mysql/mysql-bin.log\r\nexpire_logs_days = 10\r\n\r\n```\r\n\r\n### **Nginx - Web Server and Reverse Proxy**\r\nNginx was chosen for its high performance and capability to function as a reverse proxy for Python-based web applications.\r\n- Configured with gzip and static caching for improved load speeds\r\n- Supports HTTP/2 and SSL with Certbot for security\r\n- Load balancing and failover for high availability\r\n- Rate limiting to prevent DDoS attacks\r\n\r\n\r\n#### `nginx.conf` (Optimized Nginx Reverse Proxy Configuration with SSL & HTTP/2)\r\n```nginx\r\nserver {\r\n    listen 80;\r\n    server_name excelstore.gabrielchiorcea.texh;\r\n    return 301 https://$host$request_uri;\r\n}\r\n\r\nserver {\r\n    listen 443 ssl http2;\r\n    server_name excelstore.gabrielchiorcea.texh;\r\n\r\n    ssl_certificate /etc/letsencrypt/live/excelstore.gabrielchiorcea.texh/fullchain.pem;\r\n    ssl_certificate_key /etc/letsencrypt/live/excelstore.gabrielchiorcea.texh/privkey.pem;\r\n    ssl_protocols TLSv1.2 TLSv1.3;\r\n    ssl_ciphers HIGH:!aNULL:!MD5;\r\n\r\n    location / {\r\n        proxy_pass http://127.0.0.1:8000;\r\n        proxy_set_header Host $host;\r\n        proxy_set_header X-Real-IP $remote_addr;\r\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n        proxy_set_header X-Forwarded-Proto https;\r\n    }\r\n\r\n    client_max_body_size 10M;\r\n    gzip on;\r\n    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;\r\n}\r\n```\r\n\r\n\r\n### **Gunicorn - Python Application Server**\r\nGunicorn is used to run Python applications and ensure scalability.\r\n- Configured as a systemd daemon for maximum uptime\r\n- Uses worker threads to efficiently manage multiple connections\r\n- Automatic restart in case of failure for increased resilience\r\n- Supports WebSocket connections and asynchronous processing\r\n\r\n\r\n#### `gunicorn.service` (Optimized Systemd Service for Gunicorn)\r\n```ini\r\n[Unit]\r\nDescription= excelstore\r\nAfter=network.target\r\n\r\n[Service]\r\nUser=www-data\r\nGroup=www-data\r\nWorkingDirectory=/var/www/....\r\nExecStart=/usr/bin/gunicorn --workers 4 --threads 2 --bind 0.0.0.0:8000 --access-logfile /var/log/gunicorn/access.log --error-logfile /var/log/gunicorn/error.log wsgi:app\r\n\r\nRestart=always\r\nLimitNOFILE=4096\r\n\r\n[Install]\r\nWantedBy=multi-user.target\r\n```\r\n\r\n\r\n\r\n### **Jenkins - CI/CD Pipeline**\r\nJenkins is configured to automate the deployment process.\r\n- Integrated with GitHub for automatic deployment\r\n- Pipeline defined with Bash scripts to manage code in the document root\r\n- Configured with SSL for secure access\r\n- Auto-build trigger on every commit\r\n\r\n### **Monitoring and Logging**\r\nTo ensure maximum uptime and rapid issue detection, the server includes:\r\n- **Prometheus & Grafana** for metric monitoring and visual dashboards\r\n- **Fail2Ban** to detect and block unauthorized access attempts\r\n- **Elasticsearch & Kibana** for logging and traffic analysis\r\n\r\n### **Backup and Disaster Recovery**\r\nTo protect data, the server has an automated backup and recovery system:\r\n- **BorgBackup & Restic** for encrypted incremental backups\r\n- **Automatic snapshots** for quick restoration\r\n- **Disaster recovery plan** to restore the system in case of an attack\r\n\r\n### **Automation and Security**\r\nFor each new project, I have created an automation script that:\r\n- Automatically configures the application directory and Nginx vhost\r\n- Generates and installs SSL via Certbot\r\n- Adds the DNS zone in Cloudflare for easier management\r\n- Creates backups and configures automatic monitoring\r\n\r\nThe server runs in a KVM virtualized environment, providing flexibility in resource allocation and easy migration.\r\n\r\nThis project demonstrates my knowledge of administering and configuring a professional hosting server capable of running modern applications in a secure and scalable environment.\r\n\r\n---\r\n\r\n\r\n\r\n\r\n"},"nextProject":{"slug":"react-food-order-app","frontMatter":{"date":"2024-10-10","title":"Food Order App","lang":"Build with React","description":"This app use the core functionalities of a food ordering application, including menu navigation, cart management, order placement, and administrative controls. It provides a fully functional and attractive interface for users to interact with.","image":"/images/project/07.jpg","color":"#67A94C","category":"Frontend","projectInfo":[{"title":"Client","data":"World wide"},{"title":"Release date","data":"Steel in development, but ready for tests"},{"title":"Tehnology","data":"- React\n- SASS\n- FireBase\n- Redux\n- Router\n- Material-UI\n"},{"title":"Functions","data":"- Authentication and Authorization\n- Data Fetching and API Integration\n- Order state managemnet\n- Admin/User UI \n- Product createing\n"}],"live":[{"link":"https://food-order.gabrielchiorcea.eu/"}]},"content":"\n\n\n## Arhitecture. \n\n\n<div className=\"image columns-1 sm:columns-2 gap-8\">\n\n\n![React 02.](/images/project/07.jpg)\n![React 04.](/images/project/07-01.jpg)\n\n</div>\n\n\n\n\n## Description\n\nReact Meals is a web-based food ordering application developed using React and Firebase. This application allows users to browse a menu of available meals, add items to their cart, and place orders. It also includes administrative features for managing product availability.\n\n### Key Features\n1. Menu Navigation and Viewing:\n- Users can view a list of available meals, each with a description, price, and availability status.\n\n2. Add to Cart:\n- Users can add meals to their shopping cart by specifying the desired quantity.\n- The shopping cart is updated in real-time and can be viewed through a dedicated button.\n\n3. Place Orders:\n- Users can place orders by filling out a form with personal and delivery details.\n- Orders are saved in Firebase Realtime Database for further management.\n\n### Administrative Features:\n\nAdmins can manage products, updating their availability directly from the application interface. Administrative features are protected and accessible only to authorized users.\n\n<div className=\"image columns-1 sm:columns-2 gap-8\">\n\n![React 03.](/images/project/07-02.jpg)\n![React 03.](/images/project/07-03.jpg)\n![React 03.](/images/project/07-04.jpg)\n\n</div>\n\n## Technologies Used\n1. React: The main library used for building the user interface.\n2. Redux: State management to ensure a smooth and consistent user experience.\n3. Firebase: Used for authentication and real-time data storage.\n4. React Router: Manages routing and navigation within the application.\n5. Styled Components: Styles React components to create a modern and attractive interface.\n6. Material-UI: A UI component library to accelerate development and ensure design consistency.\n\n## Project Structure\nComponents: Contains all reusable components of the application, such as buttons, forms, and lists.\nPages: Contains the main pages of the application, such as the menu page, cart page, and admin page.\nStore: Contains the Redux configuration and reducers for managing the application's state.\nFirebase: Configuration for Firebase authentication and data storage.\n\n## Redux :\n\n\n```javascript\n\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst initialCartState = {\n  items: [],\n  meals: [],\n  totalAmount: 0,\n  isAdmin: false,\n  stockButton: false,\n  productButton: false,\n  orderButton: true\n\n};\n\nconst orderSlice = createSlice({\n  name: 'order',\n  initialState: initialCartState,\n  reducers: {\n    addItem(state, action) {\n      const newItem = action.payload;\n      const existingItem = state.items.find(item => item.id === newItem.id);\n      state.totalAmount += newItem.price * newItem.amount;\n      if (!existingItem) {\n        state.items.push({\n          id: newItem.id,\n          name: newItem.name,\n          amount: newItem.amount,\n          price: newItem.price,\n        });\n      } else {\n        existingItem.amount += newItem.amount;\n      }\n    },\n    removeItem(state, action) {\n      const id = action.payload;\n      const existingItem = state.items.find(item => item.id === id);\n      state.totalAmount -= existingItem.price;\n      if (existingItem.amount === 1) {\n        state.items = state.items.filter(item => item.id !== id);\n      } else {\n        existingItem.amount--;\n      }\n    },\n    addMeal(state, action) {\n      const newMeal = action.payload;\n      const existingMeal = state.meals.find(meal => meal.id === newMeal.id);\n      if (!existingMeal) {\n        state.meals.push({\n          id: newMeal.id,\n          name: newMeal.name,\n          description: newMeal.description,\n          price: newMeal.price,\n          availability: newMeal.availability,\n        });\n      }\n    },\n    clearCart(state) {\n      state.items = [];\n      state.totalAmount = 0;\n    },\n    loginAdmin(state, action) {\n      state.isAdmin = action.payload;\n    },\n\n    setStockButton(state, action) {\n      state.stockButton = action.payload;\n    },\n\n    setProductButton(state, action) {\n      state.productButton = action.payload;\n    },\n\n    setOrderButton(state, action) {\n      state.orderButton = action.payload;\n    }\n  },\n});\n\nexport const orderActions = orderSlice.actions;\nexport default orderSlice.reducer;\n\n```\n\n1. The order-slice.js file defines the initial state and the reducers for managing the cart state.\n2. The createSlice function from Redux Toolkit is used to create a slice of the state, which includes actions and reducers.\n3. The initial state includes properties like items, meals, totalAmount, isAdmin, stockButton, productButton, and orderButton.\n4. The reducers define how the state should be updated in response to actions. For example, the addItem reducer adds a new item to the cart, and the removeItem reducer removes an item from the cart.\n\n## Configuring the Redux Store:\n\nThe index.js file in the store directory configures the Redux store using the configureStore function from Redux Toolkit. The store is configured with the orderReducer created in the order-slice.js file.\n\nProviding the Redux Store to the Application:\nThe index.js file in the root directory wraps the App component with the Provider component from react-redux and passes the store to it.\nThis makes the Redux store available to all components in the application.\n\nBy using Redux for state management, the React Meals application ensures a predictable and efficient way to manage the application state. Redux helps in maintaining a single source of truth for the state, making it easier to debug and test the application. The use of Redux Toolkit simplifies the setup and reduces boilerplate code, allowing for a more streamlined development process.\n\n\n\n\n"}},"__N_SSG":true}