{"pageProps":{"currentProject":{"slug":"backend","frontMatter":{"date":"2013-10-10","title":"Backend","lang":"Build with Python","description":"Flask-based backend application providing user authentication and profile management functionalities.","image":"/images/project/04.jpg","color":"#307B93","category":"Backend","projectInfo":[{"title":"Client","data":"World wide"},{"title":"Timeline","data":"In progress, but ready for tests"},{"title":"Tehnology","data":"- Python\n- PyJWT\n- Sqlalchemy/MySQL\n- Werkzeug\n"},{"title":"Functions","data":"- User Authentication\n- Profile Management\n- Account Management \n"}],"live":[{"link":"https://backend.gabrielchiorcea.tech/"}]},"content":"\r\n## Description\r\n\r\nThis backend is a Flask-based web application that provides user authentication and profile management functionalities. It is designed to handle user sign-up, login, profile updates, and account management. The backend interacts with a MySQL database using SQLAlchemy for ORM (Object-Relational Mapping).\r\nThis backend leverages a combination of Flask, SQLAlchemy, PyJWT, MySQL, and Werkzeug to provide a robust and secure user authentication and profile management system. Flask serves as the web framework, SQLAlchemy handles database interactions, PyJWT manages token-based authentication, MySQL stores user data, and Werkzeug provides essential utilities for web application development. This technology stack ensures efficient and secure handling of user data and authentication processes.\r\n\r\n\r\n## PyJWT Usage in This Backend\r\n\r\n#### How PyJWT is Used in This Backend:\r\n\r\n1. Token Generation:\r\nWhen a user logs in, a JWT is generated using the create_access_token function. This token includes the user's ID and an expiration time. The token is then sent in the database, to the client we give a code related to the token, which stores it and includes it in the Authorization header of subsequent requests.\r\n\r\n| id \t| session_string \t| jwt                                                   \t|\r\n|----\t|----------------\t|-------------------------------------------------------\t|\r\n| 44 \t| 8PBV22S        \t| eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmcmVzaCI6Z... \t|\r\n\r\nAs can be seen, nothing relate to the id of the user, the id is inside of jwt and need special decode for extract the ID.\r\n\r\n2. Token Verification:\r\nFor protected routes, the backend verifies the JWT included in the Authorization header of incoming requests. The token is decoded using the jwt.decode function, which extracts the user's ID and other claims. If the token is valid, the request is processed; otherwise, an error response is returned.\r\n\r\n3. Session Management:\r\nThe backend uses JWTs to manage user sessions. When a user logs in, a session is created with the generated token. This session is used to authenticate the user for subsequent requests.\r\n\r\n## Key Features: \r\n### User Authentication:\r\n\r\nSign-Up: Allows users to create an account by providing an email and password. This is keeped it simple.\r\n\r\n```python\r\n@main.route('/creare-cont' , methods=['POST'])\r\ndef insert_data():\r\n    data = request.get_json()\r\n    email = data.get('email')\r\n    password = data.get('password')\r\n    firstName = data.get('firstName')\r\n    lastName = data.get('lastName')\r\n    userName = data.get('username')\r\n\r\n    try: \r\n        has = HashPass.passwordHash(password) \r\n        new_user = User( userName, email, lastName, firstName , has)\r\n        db.session.add(new_user)\r\n        db.session.commit()\r\n        return jsonify({'message': \"The user account is create with succes\"}), 201\r\n    except SQLAlchemyError as e:\r\n        db.session.rollback()\r\n        return jsonify({'error': str(e)}), 500\r\n```\r\n### User Authentication:\r\n\r\nAbout HashPass.passwordHash(password) is a special medotdh I create to hash the password, validate email format and checking for missing fields are done in the FrontEnd, checking for existing email and username \r\nI have a separated function that is used in FrontEnd when input is out of focus, the function is call via API. \r\n\r\nLogin: Users can log in using their email and password. A JWT (JSON Web Token) is generated for authenticated sessions. Dummy profile and social link data are created for new users.\r\n\r\n```python\r\n        if user:\r\n            access_token = create_access_token(identity=check_user.id, expires_delta=datetime.timedelta(days=1))    \r\n            insert_session = Session(add_session_string, access_token)\r\n            dummy_profile = ProfileCard(\r\n                occupation=\"May I ask you what do you do?\",\r\n                homeaddress=\"How far are you ?\",\r\n                country=\"I guess you are from Nice ?\",\r\n                county=\"France ?\",\r\n                user_id=check_user.id,\r\n                image=b\"\"  \r\n            )\r\n            dummy_social_links = SocialLinks(\r\n                linkedin=\"https://linkedin.com/\",\r\n                facebook=\"https://facebook.com/\",\r\n                github=\"https://github.com/\",\r\n                instagram=\"https://instagram.com/\",\r\n                twitter=\"https://twitter.com/\",\r\n                youtube=\"https://youtube.com/\",\r\n                description=\"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\",\r\n                user_id=check_user.id\r\n            )            \r\n\r\n            db.session.add(insert_session)\r\n            db.session.commit()\r\n\r\n            db.session.add(dummy_profile)\r\n            db.session.commit()\r\n\r\n            db.session.add(dummy_social_links)\r\n            db.session.commit()\r\n            return jsonify({'message': add_session_string}), 200\r\n        else:   \r\n            return jsonify({'message': 'Password or user are incorrect'}), 202\r\n```\r\n\r\n### Profile Management:\r\n\r\nSet Contact Details: Allows users to update their contact details, including occupation, home address, country, county, and profile image.\r\n\r\n\r\nSet Social Links: Allows users to update their social links, such as LinkedIn, Facebook, GitHub, Instagram, Twitter, and YouTube.\r\n\r\n```python\r\n# Retrieve the existing social links\r\n            social_links = SocialLinks.query.filter_by(user_id=user_id).first()\r\n\r\n            if social_links:\r\n                # Update the existing social links with new data\r\n                social_links.linkedin = data.get(\"linkedIn\", social_links.linkedin)\r\n                social_links.facebook = data.get(\"faceBook\", social_links.facebook)                \r\n                social_links.github = data.get(\"gitHub\", social_links.github)            \r\n                social_links.instagram = data.get(\"instagram\", social_links.instagram)            \r\n                social_links.twitter = data.get(\"twitter\", social_links.twitter)                \r\n                social_links.youtube = data.get(\"youtube\", social_links.youtube)\r\n                social_links.description = data.get(\"description\", social_links.description)\r\n```\r\nI use this approach because this is an update.\r\n\r\n\r\nGet Profile: Retrieves the user's profile information, including occupation, home address, country, county, and social links.\r\n\r\n```python\r\n    try:\r\n        decoded_token = jwt.decode(ses.jwt, secret_key, algorithms=[\"xxxxx\"])\r\n        user_id = decoded_token.get('sub')  # Extract user ID from 'sub' key\r\n    except jwt.DecodeError as e:\r\n        return jsonify({'error': 'Invalid token format', 'message': str(e)}), 400\r\n    except jwt.ExpiredSignatureError:\r\n        return jsonify({'error': 'Token has expired'}), 401\r\n    except jwt.InvalidTokenError as e:\r\n        return jsonify({'error': 'Invalid token', 'message': str(e)}), 401\r\n\r\n\r\n\r\n        `````````````````````````````````````````````````````````````````````````````````````\r\n\r\n         profile = ProfileCard.query.filter_by(user_id=user_id).first()\r\n    social_links = SocialLinks.query.filter_by(user_id=user_id).first()\r\n    user = User.query.filter_by(id=user_id).first()\r\n    if not profile:\r\n        return jsonify({'error': 'Profile or user not found'}), 404\r\n    image_base64 = base64.b64encode(profile.image).decode('utf-8')\r\n    return jsonify({\r\n        'HomeAddress': profile.homeaddress,\r\n        'Country': profile.country,\r\n        'County': profile.county,\r\n        'Occupation': profile.occupation,\r\n        'Image': image_base64,  # Assuming image is stored as binary data\r\n        'FullName': ' '.join([user.first_name, user.last_name]),\r\n        'Email': user.email,\r\n        'LinkedIn': social_links.linkedin,\r\n        'FaceBook': social_links.facebook,\r\n        'GitHub': social_links.github,\r\n        'Instagram': social_links.instagram,\r\n        'Twitter': social_links.twitter,\r\n        'Youtube': social_links.youtube,\r\n        'Description': social_links.description\r\n\r\n    }), 200\r\n```\r\n\r\n### Account Management:\r\n\r\nEverything start with chinkd the jwt:\r\n\r\n```python\r\nses = Session.query.filter_by(session_string=token).first()\r\ndecoded_token = jwt.decode(ses.jwt, secret_key, algorithms=[\"#####\"])\r\n```\r\n\r\nChange Password: Allows users to change their password by providing the current password and a new password.\r\n```python\r\n # Verify the current password\r\n        if not HashPass.check_password(user.password, current_password):\r\n            return jsonify({'message': 'Current password is incorrect'}), 400\r\n\r\n        # Update the password\r\n        user.password = HashPass.passwordHash(new_password)\r\n        db.session.commit()\r\n```\r\n\r\nChange Email: Allows users to update their email address.\r\n```python\r\n user = User.query.filter_by(id=user_id).first()\r\n        if not user:\r\n            return jsonify({'message': 'User not found'}), 404\r\n\r\n        # Update the email\r\n        user.email = new_email\r\n        db.session.commit()\r\n```\r\nChange Username: Allows users to update their username, ensuring the new username is not already taken.\r\n```python\r\nexisting_user = User.query.filter_by(username=new_username).first()\r\n        if existing_user:\r\n            return jsonify({'message': 'Username already taken'}), 400\r\n\r\n        # Update the username\r\n        user.username = new_username\r\n        db.session.commit()\r\n```\r\n\r\nDelete Account: Allows users to delete their account and all related data, including profile and social links.\r\n```python\r\nser = User.query.filter_by(id=user_id).first()\r\n        if not user:\r\n            return jsonify({'message': 'User not found'}), 404\r\n\r\n        # Delete related records\r\n        ProfileCard.query.filter_by(user_id=user_id).delete()\r\n        SocialLinks.query.filter_by(user_id=user_id).delete()\r\n\r\n        # Delete the user record\r\n        db.session.delete(user)\r\n        db.session.commit()\r\n```\r\n\r\nTechnologies Used:\r\nFlask: A lightweight WSGI web application framework in Python.\r\nSQLAlchemy: An ORM library for managing database interactions.\r\nPyJWT: A Python library for working with JSON Web Tokens.\r\nMySQL: A relational database management system for storing user data.\r\nWerkzeug: A comprehensive WSGI web application library used for password hashing and security.\r\n\r\nExample Endpoints:\r\n1.  POST /intra-in-cont: Sign up a new user.\r\n2.  POST /login: Log in an existing user.\r\n3.  GET /getProfile: Retrieve the user's profile information.\r\n4.  POST /setContactDetail: Update the user's contact details.\r\n6.  POST /setSocialLink: Update the user's social links.\r\n7.  POST /changePassword: Change the user's password.\r\n8.  POST /changeEmail: Change the user's email address.\r\n9.  POST /changeUsername: Change the user's username.\r\n10. DELETE /deleteAccount: Delete the user's account and all related data.\r\n\r\nThis backend provides a robust foundation for user authentication and profile management, ensuring secure and efficient handling of user data.\r\n\r\nThis description provides a comprehensive overview of the backend's functionality, key features, and technologies used. Adjust the details as needed to match your specific implementation.\r\n\r\n\r\n"},"nextProject":{"slug":"server","frontMatter":{"date":"2009-01-10","title":"Database","description":"A server configurate to have multiple sql server","image":"/images/project/06.jpg","color":"#BE0000","category":"Server","projectInfo":[{"title":"Client","data":"Word Wide"},{"title":"Timeline","data":"In progress"},{"title":"Tehnology","data":"- UFW firewall\n- Ubuntu 20\n- Jenkins\n- Docker\n- MySQL\n- Oracle\n- Microsoft\n"},{"title":"Functions","data":"- Database creation\n- User creation\n- Establish a remote connections\n- Open Database for dev\n"}],"live":[{"link":"#"}]},"content":"\r\n## Description:\r\nThis project focuses on configuring a server to host multiple SQL databases efficiently. It utilizes advanced technologies such as Ubuntu 20, UFW firewall for security, Jenkins for continuous integration, Docker for containerization, and support for diverse database systems including MySQL, Oracle, and Microsoft SQL Server. The primary functions include creating databases, managing user accounts, establishing secure remote connections, and making the databases accessible for development purposes. The project is currently in progress and serves a global client base, ensuring robust and scalable database management solutions tailored to diverse needs.\r\n\r\n\r\n"}},"__N_SSG":true}