{"pageProps":{"currentProject":{"slug":"backend","frontMatter":{"date":"2013-10-10","title":"Backend","lang":"Build with Python","description":"Flask-based backend application providing user authentication and profile management functionalities.","image":"/images/project/04.jpg","color":"#307B93","category":"Backend","projectInfo":[{"title":"Client","data":"World wide"},{"title":"Timeline","data":"In progress, but ready for tests"},{"title":"Tehnology","data":"- Python\n- PyJWT\n- Sqlalchemy/MySQL\n- Werkzeug\n"},{"title":"Functions","data":"- User Authentication\n- Profile Management\n- Account Management \n"}],"live":[{"link":"https://backend.gabrielchiorcea.tech/"}]},"content":"\r\n## Description\r\n\r\nThis backend is a Flask-based web application that provides user authentication and profile management functionalities. It is designed to handle user sign-up, login, profile updates, and account management. The backend interacts with a MySQL database using SQLAlchemy for ORM (Object-Relational Mapping).\r\nThis backend leverages a combination of Flask, SQLAlchemy, PyJWT, MySQL, and Werkzeug to provide a robust and secure user authentication and profile management system. Flask serves as the web framework, SQLAlchemy handles database interactions, PyJWT manages token-based authentication, MySQL stores user data, and Werkzeug provides essential utilities for web application development. This technology stack ensures efficient and secure handling of user data and authentication processes.\r\n\r\n\r\n## PyJWT Usage in This Backend\r\n\r\n#### How PyJWT is Used in This Backend:\r\n\r\n1. Token Generation:\r\nWhen a user logs in, a JWT is generated using the create_access_token function. This token includes the user's ID and an expiration time. The token is then sent in the database, to the client we give a code related to the token, which stores it and includes it in the Authorization header of subsequent requests.\r\n\r\n| id \t| session_string \t| jwt                                                   \t|\r\n|----\t|----------------\t|-------------------------------------------------------\t|\r\n| 44 \t| 8PBV22S        \t| eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmcmVzaCI6Z... \t|\r\n\r\nAs can be seen, nothing relate to the id of the user, the id is inside of jwt and need special decode for extract the ID.\r\n\r\n2. Token Verification:\r\nFor protected routes, the backend verifies the JWT included in the Authorization header of incoming requests. The token is decoded using the jwt.decode function, which extracts the user's ID and other claims. If the token is valid, the request is processed; otherwise, an error response is returned.\r\n\r\n3. Session Management:\r\nThe backend uses JWTs to manage user sessions. When a user logs in, a session is created with the generated token. This session is used to authenticate the user for subsequent requests.\r\n\r\n## Key Features: \r\n### User Authentication:\r\n\r\nSign-Up: Allows users to create an account by providing an email and password. This is keeped it simple.\r\n\r\n```python\r\n@main.route('/creare-cont' , methods=['POST'])\r\ndef insert_data():\r\n    data = request.get_json()\r\n    email = data.get('email')\r\n    password = data.get('password')\r\n    firstName = data.get('firstName')\r\n    lastName = data.get('lastName')\r\n    userName = data.get('username')\r\n\r\n    try: \r\n        has = HashPass.passwordHash(password) \r\n        new_user = User( userName, email, lastName, firstName , has)\r\n        db.session.add(new_user)\r\n        db.session.commit()\r\n        return jsonify({'message': \"The user account is create with succes\"}), 201\r\n    except SQLAlchemyError as e:\r\n        db.session.rollback()\r\n        return jsonify({'error': str(e)}), 500\r\n```\r\n### User Authentication:\r\n\r\nAbout HashPass.passwordHash(password) is a special medotdh I create to hash the password, validate email format and checking for missing fields are done in the FrontEnd, checking for existing email and username \r\nI have a separated function that is used in FrontEnd when input is out of focus, the function is call via API. \r\n\r\nLogin: Users can log in using their email and password. A JWT (JSON Web Token) is generated for authenticated sessions. Dummy profile and social link data are created for new users.\r\n\r\n```python\r\n        if user:\r\n            access_token = create_access_token(identity=check_user.id, expires_delta=datetime.timedelta(days=1))    \r\n            insert_session = Session(add_session_string, access_token)\r\n            dummy_profile = ProfileCard(\r\n                occupation=\"May I ask you what do you do?\",\r\n                homeaddress=\"How far are you ?\",\r\n                country=\"I guess you are from Nice ?\",\r\n                county=\"France ?\",\r\n                user_id=check_user.id,\r\n                image=b\"\"  \r\n            )\r\n            dummy_social_links = SocialLinks(\r\n                linkedin=\"https://linkedin.com/\",\r\n                facebook=\"https://facebook.com/\",\r\n                github=\"https://github.com/\",\r\n                instagram=\"https://instagram.com/\",\r\n                twitter=\"https://twitter.com/\",\r\n                youtube=\"https://youtube.com/\",\r\n                description=\"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\",\r\n                user_id=check_user.id\r\n            )            \r\n\r\n            db.session.add(insert_session)\r\n            db.session.commit()\r\n\r\n            db.session.add(dummy_profile)\r\n            db.session.commit()\r\n\r\n            db.session.add(dummy_social_links)\r\n            db.session.commit()\r\n            return jsonify({'message': add_session_string}), 200\r\n        else:   \r\n            return jsonify({'message': 'Password or user are incorrect'}), 202\r\n```\r\n\r\n### Profile Management:\r\n\r\nSet Contact Details: Allows users to update their contact details, including occupation, home address, country, county, and profile image.\r\n\r\n\r\nSet Social Links: Allows users to update their social links, such as LinkedIn, Facebook, GitHub, Instagram, Twitter, and YouTube.\r\n\r\n```python\r\n# Retrieve the existing social links\r\n            social_links = SocialLinks.query.filter_by(user_id=user_id).first()\r\n\r\n            if social_links:\r\n                # Update the existing social links with new data\r\n                social_links.linkedin = data.get(\"linkedIn\", social_links.linkedin)\r\n                social_links.facebook = data.get(\"faceBook\", social_links.facebook)                \r\n                social_links.github = data.get(\"gitHub\", social_links.github)            \r\n                social_links.instagram = data.get(\"instagram\", social_links.instagram)            \r\n                social_links.twitter = data.get(\"twitter\", social_links.twitter)                \r\n                social_links.youtube = data.get(\"youtube\", social_links.youtube)\r\n                social_links.description = data.get(\"description\", social_links.description)\r\n```\r\nI use this approach because this is an update.\r\n\r\n\r\nGet Profile: Retrieves the user's profile information, including occupation, home address, country, county, and social links.\r\n\r\n```python\r\n    try:\r\n        decoded_token = jwt.decode(ses.jwt, secret_key, algorithms=[\"xxxxx\"])\r\n        user_id = decoded_token.get('sub')  # Extract user ID from 'sub' key\r\n    except jwt.DecodeError as e:\r\n        return jsonify({'error': 'Invalid token format', 'message': str(e)}), 400\r\n    except jwt.ExpiredSignatureError:\r\n        return jsonify({'error': 'Token has expired'}), 401\r\n    except jwt.InvalidTokenError as e:\r\n        return jsonify({'error': 'Invalid token', 'message': str(e)}), 401\r\n\r\n\r\n\r\n        `````````````````````````````````````````````````````````````````````````````````````\r\n\r\n         profile = ProfileCard.query.filter_by(user_id=user_id).first()\r\n    social_links = SocialLinks.query.filter_by(user_id=user_id).first()\r\n    user = User.query.filter_by(id=user_id).first()\r\n    if not profile:\r\n        return jsonify({'error': 'Profile or user not found'}), 404\r\n    image_base64 = base64.b64encode(profile.image).decode('utf-8')\r\n    return jsonify({\r\n        'HomeAddress': profile.homeaddress,\r\n        'Country': profile.country,\r\n        'County': profile.county,\r\n        'Occupation': profile.occupation,\r\n        'Image': image_base64,  # Assuming image is stored as binary data\r\n        'FullName': ' '.join([user.first_name, user.last_name]),\r\n        'Email': user.email,\r\n        'LinkedIn': social_links.linkedin,\r\n        'FaceBook': social_links.facebook,\r\n        'GitHub': social_links.github,\r\n        'Instagram': social_links.instagram,\r\n        'Twitter': social_links.twitter,\r\n        'Youtube': social_links.youtube,\r\n        'Description': social_links.description\r\n\r\n    }), 200\r\n```\r\n\r\n### Account Management:\r\n\r\nEverything start with chinkd the jwt:\r\n\r\n```python\r\nses = Session.query.filter_by(session_string=token).first()\r\ndecoded_token = jwt.decode(ses.jwt, secret_key, algorithms=[\"#####\"])\r\n```\r\n\r\nChange Password: Allows users to change their password by providing the current password and a new password.\r\n```python\r\n # Verify the current password\r\n        if not HashPass.check_password(user.password, current_password):\r\n            return jsonify({'message': 'Current password is incorrect'}), 400\r\n\r\n        # Update the password\r\n        user.password = HashPass.passwordHash(new_password)\r\n        db.session.commit()\r\n```\r\n\r\nChange Email: Allows users to update their email address.\r\n```python\r\n user = User.query.filter_by(id=user_id).first()\r\n        if not user:\r\n            return jsonify({'message': 'User not found'}), 404\r\n\r\n        # Update the email\r\n        user.email = new_email\r\n        db.session.commit()\r\n```\r\nChange Username: Allows users to update their username, ensuring the new username is not already taken.\r\n```python\r\nexisting_user = User.query.filter_by(username=new_username).first()\r\n        if existing_user:\r\n            return jsonify({'message': 'Username already taken'}), 400\r\n\r\n        # Update the username\r\n        user.username = new_username\r\n        db.session.commit()\r\n```\r\n\r\nDelete Account: Allows users to delete their account and all related data, including profile and social links.\r\n```python\r\nser = User.query.filter_by(id=user_id).first()\r\n        if not user:\r\n            return jsonify({'message': 'User not found'}), 404\r\n\r\n        # Delete related records\r\n        ProfileCard.query.filter_by(user_id=user_id).delete()\r\n        SocialLinks.query.filter_by(user_id=user_id).delete()\r\n\r\n        # Delete the user record\r\n        db.session.delete(user)\r\n        db.session.commit()\r\n```\r\n\r\nTechnologies Used:\r\nFlask: A lightweight WSGI web application framework in Python.\r\nSQLAlchemy: An ORM library for managing database interactions.\r\nPyJWT: A Python library for working with JSON Web Tokens.\r\nMySQL: A relational database management system for storing user data.\r\nWerkzeug: A comprehensive WSGI web application library used for password hashing and security.\r\n\r\nExample Endpoints:\r\n1.  POST /intra-in-cont: Sign up a new user.\r\n2.  POST /login: Log in an existing user.\r\n3.  GET /getProfile: Retrieve the user's profile information.\r\n4.  POST /setContactDetail: Update the user's contact details.\r\n6.  POST /setSocialLink: Update the user's social links.\r\n7.  POST /changePassword: Change the user's password.\r\n8.  POST /changeEmail: Change the user's email address.\r\n9.  POST /changeUsername: Change the user's username.\r\n10. DELETE /deleteAccount: Delete the user's account and all related data.\r\n\r\nThis backend provides a robust foundation for user authentication and profile management, ensuring secure and efficient handling of user data.\r\n\r\nThis description provides a comprehensive overview of the backend's functionality, key features, and technologies used. Adjust the details as needed to match your specific implementation.\r\n\r\n\r\n"},"nextProject":{"slug":"server","frontMatter":{"date":"2004-01-10","title":"Hosting Server","description":"A fully configured server to host all of my projects.","image":"/images/project/06.jpg","color":"#BE0000","category":"Server","projectInfo":[{"title":"Client","data":"Worldwide"},{"title":"Timeline","data":"Completed"},{"title":"Hosting Stack","data":"- **Operating System:** Ubuntu 20.04 LTS\n- **Firewall:** UFW (Uncomplicated Firewall)\n- **Database:** MariaDB\n- **Web Server:** Nginx\n- **Application Server:** Gunicorn\n- **Programming Language:** Python\n- **CI/CD Pipeline:** Jenkins\n- **Monitoring & Logging:** Prometheus & Grafana\n- **Backup & Recovery:** BorgBackup & Restic\n- **Infrastructure as Code:** Ansible & Terraform\n"},{"title":"Functions","data":"- High-performance web hosting\n- Automated deployment\n- Secure and scalable infrastructure\n- Continuous monitoring and alerting\n- Automated backups and disaster recovery\n"}],"live":[{"link":"#"}]},"content":"\r\n## Server Configuration\r\n\r\nTo analyze the implemented configurations, a live session can be arranged where I will provide access for a joint review.\r\n\r\nThis project represents a dedicated hosting server for all my applications, configured to provide performance, security, and scalability. The server is optimized to run modern applications with minimal response time and high reliability.\r\n\r\n### **Firewall (UFW)**\r\nUncomplicated Firewall (UFW) is configured to protect the server by restricting access to necessary ports.\r\n- HTTP (80) and HTTPS (443) for web access\r\n- SSH with IP restrictions for security, dedicate IP.\r\n- Custom ports for internal services\r\n- Rate limiting for brute-force attack protection\r\n\r\n###  **Operating System - Ubuntu 20.04 LTS**\r\nUbuntu 20.04 LTS was chosen for its stability, long-term support, and excellent compatibility with most server-side applications.\r\n- Optimized kernel for performance and security\r\n- Swap tuning for efficient memory management\r\n- Automatic security updates and periodic security audits\r\n\r\n###  **MariaDB - Database Management System**\r\nMariaDB is installed to support applications that require data storage, especially those involving user authentication and account management.\r\n- Configured with master-slave replication for redundancy\r\n- Optimized for performance using query caching and indexing\r\n- Automatic daily backup and fast recovery when needed\r\n- Secure access via SSL connections and role-based authentication\r\n\r\n\r\n```ini\r\n[mysqld]\r\nbind-address = 127.0.0.1\r\nmax_connections = 500\r\nthread_cache_size = 128\r\ntable_open_cache = 4000\r\nquery_cache_type = 1\r\nquery_cache_size = 64M\r\nquery_cache_limit = 2M\r\ntmp_table_size = 64M\r\nmax_heap_table_size = 64M\r\ninnodb_buffer_pool_size = 1G\r\ninnodb_log_file_size = 256M\r\ninnodb_flush_log_at_trx_commit = 1\r\ninnodb_flush_method = O_DIRECT\r\ninnodb_file_per_table = 1\r\ninnodb_read_io_threads = 8\r\ninnodb_write_io_threads = 8\r\nlog_error = /var/log/mysql/error.log\r\nslow_query_log = 1\r\nslow_query_log_file = /var/log/mysql/slow.log\r\nlong_query_time = 1\r\nserver-id = 1\r\nlog_bin = /var/log/mysql/mysql-bin.log\r\nexpire_logs_days = 10\r\n\r\n```\r\n\r\n### **Nginx - Web Server and Reverse Proxy**\r\nNginx was chosen for its high performance and capability to function as a reverse proxy for Python-based web applications.\r\n- Configured with gzip and static caching for improved load speeds\r\n- Supports HTTP/2 and SSL with Certbot for security\r\n- Load balancing and failover for high availability\r\n- Rate limiting to prevent DDoS attacks\r\n\r\n\r\n#### `nginx.conf` (Optimized Nginx Reverse Proxy Configuration with SSL & HTTP/2)\r\n```nginx\r\nserver {\r\n    listen 80;\r\n    server_name excelstore.gabrielchiorcea.texh;\r\n    return 301 https://$host$request_uri;\r\n}\r\n\r\nserver {\r\n    listen 443 ssl http2;\r\n    server_name excelstore.gabrielchiorcea.texh;\r\n\r\n    ssl_certificate /etc/letsencrypt/live/excelstore.gabrielchiorcea.texh/fullchain.pem;\r\n    ssl_certificate_key /etc/letsencrypt/live/excelstore.gabrielchiorcea.texh/privkey.pem;\r\n    ssl_protocols TLSv1.2 TLSv1.3;\r\n    ssl_ciphers HIGH:!aNULL:!MD5;\r\n\r\n    location / {\r\n        proxy_pass http://127.0.0.1:8000;\r\n        proxy_set_header Host $host;\r\n        proxy_set_header X-Real-IP $remote_addr;\r\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n        proxy_set_header X-Forwarded-Proto https;\r\n    }\r\n\r\n    client_max_body_size 10M;\r\n    gzip on;\r\n    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;\r\n}\r\n```\r\n\r\n\r\n### **Gunicorn - Python Application Server**\r\nGunicorn is used to run Python applications and ensure scalability.\r\n- Configured as a systemd daemon for maximum uptime\r\n- Uses worker threads to efficiently manage multiple connections\r\n- Automatic restart in case of failure for increased resilience\r\n- Supports WebSocket connections and asynchronous processing\r\n\r\n\r\n#### `gunicorn.service` (Optimized Systemd Service for Gunicorn)\r\n```ini\r\n[Unit]\r\nDescription= excelstore\r\nAfter=network.target\r\n\r\n[Service]\r\nUser=www-data\r\nGroup=www-data\r\nWorkingDirectory=/var/www/....\r\nExecStart=/usr/bin/gunicorn --workers 4 --threads 2 --bind 0.0.0.0:8000 --access-logfile /var/log/gunicorn/access.log --error-logfile /var/log/gunicorn/error.log wsgi:app\r\n\r\nRestart=always\r\nLimitNOFILE=4096\r\n\r\n[Install]\r\nWantedBy=multi-user.target\r\n```\r\n\r\n\r\n\r\n### **Jenkins - CI/CD Pipeline**\r\nJenkins is configured to automate the deployment process.\r\n- Integrated with GitHub for automatic deployment\r\n- Pipeline defined with Bash scripts to manage code in the document root\r\n- Configured with SSL for secure access\r\n- Auto-build trigger on every commit\r\n\r\n### **Monitoring and Logging**\r\nTo ensure maximum uptime and rapid issue detection, the server includes:\r\n- **Prometheus & Grafana** for metric monitoring and visual dashboards\r\n- **Fail2Ban** to detect and block unauthorized access attempts\r\n- **Elasticsearch & Kibana** for logging and traffic analysis\r\n\r\n### **Backup and Disaster Recovery**\r\nTo protect data, the server has an automated backup and recovery system:\r\n- **BorgBackup & Restic** for encrypted incremental backups\r\n- **Automatic snapshots** for quick restoration\r\n- **Disaster recovery plan** to restore the system in case of an attack\r\n\r\n### **Automation and Security**\r\nFor each new project, I have created an automation script that:\r\n- Automatically configures the application directory and Nginx vhost\r\n- Generates and installs SSL via Certbot\r\n- Adds the DNS zone in Cloudflare for easier management\r\n- Creates backups and configures automatic monitoring\r\n\r\nThe server runs in a KVM virtualized environment, providing flexibility in resource allocation and easy migration.\r\n\r\nThis project demonstrates my knowledge of administering and configuring a professional hosting server capable of running modern applications in a secure and scalable environment.\r\n\r\n---\r\n\r\n\r\n\r\n\r\n"}},"__N_SSG":true}