{"pageProps":{"currentPost":{"slug":"cerbot","frontMatter":{"title":"How to Install and Use Let's Encrypt SSL on Your Server (Apache & Nginx)","description":"Certbot is the recommended client for obtaining and renewing SSL certificates from Let's Encrypt. The installation process depends on your Linux distribution (or operating system), but the following steps are for Ubuntu. The process is similar for other distributions.","image":"/images/blog/cerbot.jpg","date":"2024-12-20","category":"Server"},"content":"\nLet’s Encrypt uses Automatic Certificate Management Environment (ACME) protocol to automate the process of obtaining and installing SSL certificates. The most common ACME client is Certbot, which is responsible for obtaining the certificates from Let’s Encrypt and configuring the server.\n\nLet’s Encrypt certificates are domain-validated certificates, meaning they only verify the ownership of the domain and not the identity of the organization behind it. This is why they are ideal for personal blogs, small businesses, or any website that doesn’t require extended validation (EV) certificates.\n\n## Install Certbot\n## On Ubuntu/Debian.\nUpdate existing packages:\n\n```bash\nsudo apt update\nsudo apt upgrade\n```\n## Install Certbot and the plugin for Nginx or Apache (depending on your web server):\n\nFor Nginx:\n```bash\nsudo apt install certbot python3-certbot-nginx\n```\n\nFor Apache:\n```bash\nsudo apt install certbot python3-certbot-apache\n```\n\n## On CentOS/RHEL.\nInstall EPEL repository (for CentOS 7 and below):\n\n```bash\nsudo yum install epel-release\n```\n\n\nInstall Certbot:\n\n```bash\nsudo yum install certbot python2-certbot-nginx\n```\n## Obtain the SSL Certificate\nAfter installation, you can obtain an SSL certificate for your domain. Certbot will automatically check if your domain is configured correctly and request the certificate from Let's Encrypt.\n\nFor Nginx:\n```bash\nsudo certbot --nginx\n```\n\nFor Apache:\n```bash\nsudo certbot --apache\n```\nCertbot will ask you to enter your email address and accept the terms and conditions. It will then automatically verify your domain and configure the web server to use the SSL certificate.\n\nSet Up Automatic Certificate Renewal\nLet's Encrypt certificates are valid for only 90 days. It’s important to set up automatic renewal.\n\nCertbot includes a cron job to handle automatic renewals, but you can check it by running:\n\n```bash\nsudo certbot renew --dry-run\n```\nThis simulates the renewal process and will show you if everything is working fine.\n\n## Check the Installation\nOnce you've configured Let's Encrypt, you can check that SSL is working by accessing your site using https:// in front of your domain. You can also verify with an online tool like SSL Labs.\n\nConfigure HTTP to HTTPS Redirection\nTo ensure that all visitors to your site are using HTTPS, you should redirect all HTTP traffic to HTTPS. If you used the Certbot plugin for Nginx or Apache, it will automatically configure this redirection.\n\n\n1. For Nginx:\n\nExample of SSL Configuration in Nginx (yourdomain.com.conf):\n\n```bash\nserver {\n    listen 80;\n    server_name yourdomain.com www.yourdomain.com;\n    return 301 https://$host$request_uri;\n}\n\nserver {\n    listen 443 ssl;\n    server_name yourdomain.com www.yourdomain.com;\n\n    ssl_certificate /etc/letsencrypt/live/yourdomain.com/fullchain.pem;\n    ssl_certificate_key /etc/letsencrypt/live/yourdomain.com/privkey.pem;\n\n    location / {\n        root /var/www/yourdomain;\n        index index.html index.php; #etc\n    }\n}\n\n```\n\nIn the server block configuration (usually /etc/nginx/sites-available/default), add a section for HTTP to HTTPS redirection:\n\n```bash\nserver {\n    listen 80;\n    server_name yourdomain.com www.yourdomain.com;\n    return 301 https://$host$request_uri;\n}\n```\n\n2. For Apache:\n\nIn your Apache configuration file (located in /etc/apache2/sites-available/), ensure there’s a VirtualHost block for HTTPS (port 443) and an HTTP to HTTPS redirection block.\n\nExample of SSL Configuration in Apache (default-ssl.conf):\n\n```bash\n<VirtualHost *:443>\n    ServerAdmin webmaster@yourdomain.com\n    DocumentRoot /var/www/yourdomain\n    ServerName yourdomain.com\n    ServerAlias www.yourdomain.com\n\n    SSLEngine on\n    SSLCertificateFile /etc/letsencrypt/live/yourdomain.com/fullchain.pem\n    SSLCertificateKeyFile /etc/letsencrypt/live/yourdomain.com/privkey.pem\n    SSLCertificateChainFile /etc/letsencrypt/live/yourdomain.com/chain.pem\n\n    ErrorLog ${APACHE_LOG_DIR}/error.log\n    CustomLog ${APACHE_LOG_DIR}/access.log combined\n\n    # Redirect HTTP to HTTPS\n    <IfModule mod_rewrite.c>\n        RewriteEngine On\n        RewriteCond %{HTTPS} off\n        RewriteRule ^ https://%{HTTP_HOST}%{REQUEST_URI} [L,R=301]\n    </IfModule>\n</VirtualHost>\n\n```\n\nThen enable SSL and the default-ssl site configuration:\n\n```bash\nsudo a2enmod ssl\nsudo a2ensite default-ssl\nsudo systemctl restart apache2\n\n```\nAdd this rule in your .htaccess file or Apache configuration:\n\n```bash\nRewriteEngine On\nRewriteCond %{HTTPS} off\nRewriteRule ^ https://%{HTTP_HOST}%{REQUEST_URI} [L,R=301]\n```\n\n\nPeriodically Check Certificates\nSetting up and using Let's Encrypt SSL certificates is a straightforward process with Certbot, ensuring that your website traffic is encrypted and secure. Whether you're using Apache or Nginx, this guide provides the necessary steps to configure SSL and redirect HTTP to HTTPS.\n\nBy regularly checking your SSL certificates and ensuring automatic renewals, you can maintain a secure and trusted website for your visitors.\n\n\n\n\n\n\n\n\n"},"previousPost":{"slug":"Apache-on-Ubuntu-22.04-Using-Docker","frontMatter":{"title":"How to Install Apache on Ubuntu 22.04 Using Docker","description":"Apache is one of the most widely used web servers, providing a robust platform for hosting websites and web applications.","image":"/images/blog/docker.jpg","date":"2024-12-23","category":"Server"},"content":"\n\n\nApache is one of the most widely used web servers, providing a robust platform for hosting websites and web applications. With the power of Docker, you can easily run Apache in an isolated container, making your setup portable and quick to deploy. In this blog post, we will walk you through the steps to install and run Apache on Ubuntu 22.04 using Docker. This setup is perfect for testing, development, or production environments.\n\n## What You'll Learn.\n\n\nIn this guide, you'll learn:\n\n1.  How to install Docker on Ubuntu 22.04.\n2.  How to pull and run Apache in a Docker container.\n3.  Basic management of your Apache Docker container.\n4.  How to troubleshoot any potential issues during the setup.\n\n## Step 1 Install Docker on Ubuntu 22.04\n\nBefore we begin setting up Apache, we need to ensure that Docker is installed on your system. Docker allows us to run Apache within a container, providing a lightweight and efficient environment. Follow these steps to get Docker up and running:\n\n1.1 Update Your System\n\nStart by updating your package lists to make sure you’re working with the latest versions of the software.\n\n```bash\nsudo apt update\nsudo apt upgrade -y\n```\n\n1.2 Install Required Dependencies\n\nNext, we’ll install some necessary dependencies to allow Docker to be added to the system.\n\n```bash\nsudo apt install -y apt-transport-https ca-certificates curl software-properties-common\n```\n\n1.3 Add Docker’s Official GPG Key\n\nNow, you need to add Docker’s official GPG key to your system so it can verify the Docker package authenticity.\n\n\n**curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg**\n\n1.4 Add Docker’s Repository\n\nAdd Docker’s official repository to your system’s list of sources, so you can install the latest version of Docker from it.\n\n\n**echo \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null**\n\n\n1.5 Install Docker\n\nNow you can install Docker. After updating your package list, install Docker using the following command:\n\n```bash\nsudo apt update\nsudo apt install -y docker-ce docker-ce-cli containerd.io\n```\n\n1.6 Verify Docker Installation\n\nTo confirm Docker was installed successfully, check the version of Docker installed:\n\n```bash\nsudo docker --version\n```\n## Step 2 Run Apache in a Docker Container\n\nNow that Docker is installed, it's time to pull the official Apache image and run it in a container. Docker makes it incredibly easy to run a fully functional Apache web server without the need to configure anything manually.\n\n2.1 Pull the Official Apache Image\n\nDocker Hub has a ready-to-use official Apache image, so you don't have to create one from scratch. Pull the image by running:\n\n```bash\nsudo docker pull httpd\n```\n2.2 Run Apache in a Docker Container\n\nWith the Apache image pulled, we can now run it in a container. This will start Apache and bind it to your machine's port 8080:\n\n```bash\nsudo docker run -d -p 8080:80 --name apache-server httpd\n```\n-d: Runs the container in detached mode (in the background).\n-p 8080:80: Maps port 80 inside the container (the default Apache port) to port 8080 on your host machine.\n--name apache-server: Names your container \"apache-server\" for easy reference.\n\n2.3 Verify the Apache Container is Running\n\nTo check if your container is running properly, you can use:\n```bash\nsudo docker ps\n```\nThis command will list all running containers, and you should see your apache-server container in the list.\n\n2.4 Access Apache in Your Browser\n\nNow, open your browser and navigate to http://localhost:8080 or http://<your-server-ip>:8080 (if you're working on a remote machine). You should see the default Apache welcome page, which indicates that Apache is running inside the Docker container.\n\n## Step 3 Managing Your Apache Docker Container\n\nOnce your Apache server is running, you may need to perform some basic container management tasks. Here are some useful commands:\n\n3.1 Stop the Apache Container\n\nIf you need to stop the Apache container, you can use the following command:\n\n```bash\nsudo docker stop apache-server\n```\n3.2 Start the Apache Container Again\n\nTo start the container again after stopping it:\n\n```bash\nsudo docker start apache-server\n```\n\n3.3 Remove the Apache Container\n\nIf you want to remove the container (for example, when cleaning up), use this command:\n\n```bash\nsudo docker rm apache-server\n```\n3.4 View Apache Logs\n\nTo view the logs generated by Apache inside the container:\n\n```bash\nsudo docker logs apache-server\n```\n\n## Step 4 Customize Your Apache Setup\n\nAt this point, you have Apache running in Docker with its default configuration. However, Docker allows for greater flexibility, enabling you to configure Apache further. You can mount configuration files or a custom website directory into your container, or even create a custom Dockerfile to suit your specific needs.\n\n4.1 Mounting Local Directories to Docker\n\nIf you want to serve your custom website, you can mount your local directory to the Apache container:\n```bash\nsudo docker run -d -p 8080:80 -v /path/to/your/website:/usr/local/apache2/htdocs/ --name apache-server httpd\n```\nThis command mounts the website directory on your host machine to the htdocs folder in the Apache container, where Apache looks for files to serve.\n\n## Troubleshooting Common Issues\n\nDocker Image Pull Failures: Ensure you have a stable internet connection. If you encounter issues while pulling the Apache image, try running docker system prune to clear unused data and try again.\nPort Conflicts: If port 8080 is already in use, you can change the host port (e.g., -p 8081:80) when running the container.\nApache Errors: To check for any issues with Apache itself, use docker logs apache-server to view the container's log output.\n\n## Conclusion\nCongratulations! You’ve successfully set up Apache on Ubuntu 22.04 using Docker. This method is a clean and efficient way to run a web server, with the added benefits of Docker’s portability and ease of use. You can now scale your Apache setup, customize it, or even deploy it in production with minimal effort. Docker makes managing your server environments a breeze, and using Apache in a containerized environment is a powerful choice for modern web hosting.\n\nIf you want to take it a step further, you can integrate Docker Compose to manage multi-container applications or even link Apache with a MySQL or PHP container for dynamic website hosting.\n\nHappy coding, and enjoy your new Apache web server!"},"nextPost":{"slug":"Memoization","frontMatter":{"title":"How to Optimize React Performance with Memoization","description":"React apps can become slow and unresponsive as they grow larger and more complex. One powerful way to boost performance is by using **memoization** — a technique that caches the results of expensive function calls and returns the cached result when the same inputs occur again.","image":"/images/blog/react.png","date":"2025-06-16","category":"Server"},"content":"\n\n   \n\n# How to Optimize React Performance with Memoization 🚀\n\n  \n\nReact apps can become slow and unresponsive as they grow larger and more complex. One powerful way to boost performance is by using **memoization** — a technique that caches the results of expensive function calls and returns the cached result when the same inputs occur again.\n\n  \n\nIn this post, I’ll walk you through how to use memoization effectively in React, focusing on the built-in hooks and components that help you avoid unnecessary re-renders.\n\n  \n\n---\n\n  \n\n## What is Memoization?\n\n  \n\nMemoization is an optimization technique that stores (\"memoizes\") the result of a function call based on its inputs. If the function is called again with the same inputs, the cached result is returned instead of recomputing.\n\n  \n\nIn React, this helps prevent unnecessary rendering and computation, which can improve app responsiveness and reduce CPU usage.\n\n  \n\n---\n\n  \n\n## React Memoization Tools\n\n  \n\nReact provides several tools to help with memoization:\n\n  \n\n- `React.memo` — memoizes functional components, preventing re-render if props don’t change.\n\n- `useMemo` — memoizes the result of a calculation between renders.\n\n- `useCallback` — memoizes a callback function reference, preventing unnecessary re-creations.\n\n  \n\n---\n\n  \n\n## When to Use `React.memo`\n\n  \n\nUse `React.memo` to wrap functional components that receive props and only need to re-render when those props change.\n\n  \n\n```jsx\n\nimport React from  'react';\n\n  \n\nconst  ExpensiveComponent  = React.memo(({ data }) => {\n\nconsole.log('Rendering ExpensiveComponent');\n\n// expensive calculations or rendering here\n\nreturn <div>{data}</div>;\n\n});\n```\n\n## Using useMemo for Expensive Calculations\n\nIf you have heavy computations inside your component, use useMemo to cache the results:\n\n  \n\n```jsx\nimport React, { useMemo } from  'react';\n\n  \n\nfunction  Fibonacci({ n }) {\n\n// useMemo will recompute the value only when `n` changes\n\nconst  fib  =  useMemo(() => {\n\nfunction  calcFib(num) {\n\nif (num <=  1) return  1;\n\nreturn  calcFib(num -  1) +  calcFib(num -  2);\n\n}\nreturn  calcFib(n);\n\n}, [n]); // dependency array: recalc only if `n` changes\n\nreturn <div>Fibonacci number: {fib}</div>;\n\n}\n```\n  \n\n## Why use useMemo here?\n\nWithout useMemo, the calcFib function  would  be  called  on  every  render, which  can  be  very  expensive  especially  for  large  n.\n\nWith  useMemo, React  caches  the  result  of  the  calculation  and  only  recomputes  it  if  n  changes, saving  CPU  time  and  improving  performance.\n\n\n# Using  useCallback  to  Memoize  Functions\n\nPassing  inline  functions  as  props  causes  child  components  to  re-render  unnecessarily  because  every  render  creates  a  new  function  reference.\n\n\nuseCallback  returns  a  memoized  version  of  the  function  that  only  changes  if  its  dependencies  change.\n\n  \n\n```jsx\n\nimport  React, { useState, useCallback } from 'react';\n\nconst Button = React.memo(({ onClick, children }) => {\n\nconsole.log('Button rendered');\n\nreturn <button  onClick={onClick}>{children}</button>;\n\n});\n\n\nfunction  Parent() {\n\nconst [count, setCount] =  useState(0);\n\n  \n\n// Memoize increment function to prevent new function creation on every render\n\nconst  increment  =  useCallback(() => {\n\nsetCount(c  => c +  1);\n\n}, []); // empty dependency array means function stays the same\n\n  \n\nreturn (\n\n<div>\n\n<p>Count: {count}</p>\n\n<Button  onClick={increment}>Increment</Button>\n\n</div>\n\n);\n\n}\n```\n\n## Why use useCallback?\n\nWithout useCallback, the increment function  would  be  recreated  on  every  render.\n\n  \n\nThis  causes  Button  to  re-render  even  if  its  props  appear  unchanged.\n\n  \n\nWith  useCallback, the  function  reference  stays  the  same  between  renders  unless  dependencies  change, so  Button  only  re-renders  when  needed.\n\n  \n\nSummary\n\n1. Use  React.memo  to  memoize  entire  functional  components  to  avoid  unnecessary  re-renders  when  props  are  unchanged.\n\n  \n\n2. Use  useMemo  to  memoize  expensive  calculations  inside  components.\n\n  \n\n3. Use  useCallback  to  memoize  functions  passed  as  props  to  prevent  unnecessary  re-creation  of  functions  and  child  re-renders.\n\n  \n\nProper  use  of  these  memoization  techniques  can  help  your  React  apps  run  faster  and  more  efficiently."}},"__N_SSG":true}